namespace Rosella { namespace Test
{
    namespace Loader
    {
        // Helper routine to generate a loader and extract a list of tests
        // from a Testcase
        function load(var loaderproto, var testproto, var loaderopts)
        {
            using Rosella.build;
            var loader = build(loaderproto, testproto, loaderopts:[named,flat]);
            var tests = loader.load_tests();
            return tests;
        }
    }

    /* Test Loader class. This class takes a reference to a test type and
       creates a list of Testcase objects for it. That list of test cases
       is fed into a Suite object to run.

       The Loader is created with a single test type. It extracts methods from
       that type and inserts them into a Suite.
    */
    class Loader
    {
        var class_obj;    // The Parrot Class
        var proto_obj;    // The type key (Class, P6protoobject, etc)
        var seen_methods; // A list of methods we've already seen, so we don't duplicate
        var test_prefix;  // prefix for valid tests

        // Constructor. Take the test proto object and a few other options
        function BUILD(var test_proto,
                string test_prefix [named,optional], int has_prefix [opt_flag])
        {
            using Rosella.get_type_class;
            self.proto_obj = test_proto;
            self.class_obj = get_type_class(test_proto);
            if (has_prefix)
                self.test_prefix = test_prefix;
            else
                self.test_prefix = "test_";
            self.seen_methods = {};
        }

        // Load and return a list of tests
        function load_tests()
        {
            using Rosella.build;
            var test_names = self.get_test_methods();
            test_names = self.order_tests(test_names);
            var tests = [];

            for (var test_name in test_names) {
                var test_obj = build(self.proto_obj, test_name);
                push(tests, test_obj);
            }
            return tests;
        }

        // Get a list of all test methods, searching up the MRO for any
        // methods which match the prefix.
        function get_test_methods()
        {
            var mro = self.class_obj.inspect("all_parents");
            var test_methods = [];
            for (var parent in mro) {
                var methods = parent.inspect("methods");
                for (var method in methods) {
                    if (self.is_test_method(method) && !(exists self.seen_methods[method])) {
                        self.seen_methods[method] = 1;
                        test_methods.push(method);
                    }
                }
            }
            return test_methods;
        }

        // Determine if this is a test method or not. There are a handful of
        // utility methods in Testcase, and others which the user can add too.
        function is_test_method(string name)
        {
            int is_test = 0;
            int prefix_length = length(self.test_prefix);
            if (length(name) > prefix_length &&
                substr(name, 0, prefix_length) == self.test_prefix) {
                is_test = 1;
            }
            return is_test;
        }

        // Order the list of test methods. In the default case do no
        // ordering. Subclasses can override this.
        function order_tests(var tests)
        {
            return tests;
        }
    }
}}
