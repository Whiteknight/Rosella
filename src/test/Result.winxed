/* Test Result Class. The Result monitors the running suite and handles
   test events. The Result maintains a list of Listener objects, and
   broadcasts events to all Listeners. Unless specified otherwise, the
   default Listener is Rosella::Test::Listener::TAP.
*/
class Rosella.Test.Result
{
    var total_tests;
    var num_failures;
    var listeners;
    var expected_tests;

    // Constructor. Take a list of listeners and initialize the Result
    function Result(var listeners)
    {
        self.total_tests = 0;
        self.num_failures = 0;
        self.expected_tests = 0;
        self.listeners = listeners;
    }

    /* Interface Methods
    */

    // set the expected number of tests to run
    function plan_tests(int num_tests)
    {
        if (num_tests < 0)
            Rosella.Error.invalid(__FUNCTION__, "Invalid plan");
        self.expected_tests = num_tests;
        for (var listener in self.listeners)
            listener.plan_tests(num_tests);
    }

    // Start a test
    function start_test(var test, var context)
    {
        self.total_tests = self.total_tests + 1;
        for (var listener in self.listeners)
            listener.start_test(test);
    }

    // Add a failure test. This picks out the type of failure (either an
    // assertion failure or a stray exception), and passes on the data
    // to the relevant methods on the Listener.
    function add_failure(var test, var context, var ex)
    {
        self.num_failures = self.num_failures + 1;
        string label = context.display_name();
        string todo = context.test_todo();

        if (Rosella.isa_type("String", ex)) {
            for (var listener in self.listeners)
                listener.add_failure_msg(test, label, todo, ex);
            return;
        }

        for (var listener in self.listeners)
            listener.add_exception(test, label, todo, ex);
    }

    // End the test, presuming success
    function end_test(var test, var context)
    {
        string label = context.display_name();
        string todo = context.test_todo();
        for (var listener in self.listeners)
            listener.end_test(test, label, todo);
    }

    // Boolean whether the whole run was successful
    function was_successful()
    {
        return int(self.num_failures) == 0;
    }

    // Tell the listeners that all tests have executed
    function tests_complete()
    {
        int expected_tests = int(self.expected_tests);
        int total_tests = int(self.total_tests);
        int num_failures = int(self.num_failures);
        for (var listener in self.listeners)
            listener.tests_complete(expected_tests, total_tests, num_failures);
    }
}
