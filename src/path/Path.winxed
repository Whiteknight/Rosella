namespace Rosella
{
    class Path
    {
        var separator;
        var searchers;

        function Path(var searchers [slurpy],
                string separator [optional,named], int has_sep [opt_flag])
        {
            using Rosella.build;

            if (has_sep)
                self.separator = separator;
            else
                self.separator = ".";
            if (elements(searchers) == 0) {
                self.searchers = [];
                self.searchers[0] = build(class Rosella.Path.Searcher.Hash);
                self.searchers[1] = build(class Rosella.Path.Searcher.Attribute);
            }
            else
                self.searchers = searchers;
        }

        function result_is_valid(var result)
        {
            if (result == null)
                return 0;
            int is_defined = 0;
            ${ defined is_defined, result };
            return is_defined;
        }

        function get(var obj, string path)
        {
            int success;
            var result;
            :(success, result) = self.get_recursive(obj, path);

            if (success)
                return result;
            return null;
        }

        function get_recursive(var obj, string path)
        {
            //say("searching for '" + path + "'");
            if (path == null || path == "") {
                //say("found immediately");
                return 1, obj;
            }

            string next_path = path;
            string search_text = path;
            string remainder = "";
            int idx = length(path) - 1;

            //say(sprintf("search = '%s' remainder = '%s'", [search_text, remainder]));
            while (idx >= 0) {
                //say(sprintf("search = '%s' remainder = '%s'", [search_text, remainder]));
                int success = 0;
                //say(sprintf("search = '%s' remainder = '%s'", [search_text, remainder]));
                var result = null;
                //say(sprintf("search = '%s' remainder = '%s'", [search_text, remainder]));

                for (var searcher in self.searchers) {
                    //say(sprintf("\tSearching %s for '%s'", [typeof(searcher), search_text]));
                    if (!searcher.can_search(obj))
                        continue;
                    var result;

                    :(success, result) = searcher.search(obj, search_text);
                    if (success) {
                        //say("\tfound");
                        obj = result;
                        break;
                    }
                    //say("\tnot found");
                }

                if (success) {
                    if (remainder == null || remainder == "") {
                        //say("found non-recursive");
                        return 1, obj;
                    }
                    :(success, result) = self.foo(obj, remainder);
                    if (success) {
                        //say("\tfound after recursive");
                        return 1, result;
                    }
                }
                else {
                    idx = search_text.reverse_index(self.separator, 0);
                    remainder = substr(next_path, idx + 1);
                    search_text = substr(search_text, 0, idx);

                }
            }
            //say("LOOP TERMINATED");

            return 0, null;
        }

        function foo(var obj, string rem)
        {
            int success;
            var result;
            :(success, result) = self.get_recursive(obj, rem);
            return success, result;
        }
    }
}
