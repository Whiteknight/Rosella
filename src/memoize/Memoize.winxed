
// Here's one idea for a memoizer which doesn't use Proxy as a base. We don't
// have as much flexibility here as we might with Proxy.
namespace Rosella { namespace Memoize
{
    // Create a simple memoizer. In the simple case, the user cannot get
    // access to the cache or the memoized function after the memoizer has
    // been created
    function memoize(var func, var cache [optional], int has_cache [opt_flag])
    {
        if (!has_cache)
            cache = new Rosella.Memoize.Cache.SimpleString;
        var _cache = cache;
        var f = func;

        var memfunc = function(var p [slurpy], var n [named,slurpy]) {
            var cache_item = _cache.get_item(p, n);
            if (cache_item.valid)
                return cache_item.value;
            var value = f(p:[flat], n:[flat,named]);
            cache_item.update_value(value);
            return value;
        };
        return memfunc;
    }

    function private_get_memoize_factory()
    {
        var factory = new Rosella.Memoize.Factory();
        while(1)
            yield(factory);
    }

    // Memoize a function using a proxy-based approach. Proxy-based memoizers
    // are heavier and a little slower, but allow the user to access the
    // cache and the original function directly, in addition to a few other
    // features inherent in Rosella's proxy implementation
    function memoize_proxy(var func, var cache [optional], int has_cache [opt_flag])
    {
        var factory = private_get_memoize_factory();
        var args = [func];
        if (has_cache)
            args[1] = cache;
        return factory.create(args:[flat]);
    }

    function memoize_method(var type, string method_name,
            var cache [optional], int has_cache [opt_flag])
    {
        using Rosella.get_type_class;
        var type_class = get_type_class(type);
        var method = type_class["methods"][method_name];
        if (method == null) {
            using Rosella.invalid;
            invalid("Memoize.memoize_method", "The method does not exist");
        }
        var cache_args = [];
        if (has_cache)
            cache_args[0] = cache;
        var proxy = memoize_proxy(method, cache_args:[flat]);
        type_class.remove_method(method_name);
        type_class.add_method(method_name, proxy);
    }

    function unmemoize_method(var type, string method_name)
    {
        using Rosella.get_type_class;
        var type_class = get_type_class(type);
        // TODO: Determine if the method is actually a proxy, before
        // attempting to disassemble it.

        var proxy = type_class["methods"][method_name];
        using Rosella.Proxy.get_proxy_private_attr;
        var method = get_proxy_private_attr(proxy, "target_object");
        type_class.remove_method(method_name);
        type_class.add_method(method_name, method);
    }

    // TODO: Method to memorize a method in-place (open the Class, replace the
    //       method object). Ability to undo.

    // Y combinator with built-in memoization. Inspired by matt.might.net
    function Y(var f,
            var cache [optional,named], int has_cache [opt_flag])
    {
        if (!has_cache)
            cache = new Rosella.Memoize.Cache.SimpleString;
        var _cache = cache;
        var F = f;

        return function(var p [slurpy], var n [slurpy,named]) {
            var cache_item = _cache.get_item(p, n);
            if (cache_item.valid)
                return cache_item.value;
            var value = (F(function(var _p [slurpy], var _n [slurpy,named]) {
                return (Y(F, _cache))(_p:[flat], _n:[flat,named]);
            }))(p:[flat], n:[flat,named]);
            cache_item.update_value(value);
            return value;
        };
    }
}}
