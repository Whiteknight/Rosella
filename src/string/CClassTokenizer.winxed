namespace Rosella { namespace String
{
    namespace CClassTokenizer
    {
        // Get a default list of character classes, if none are provided
        function private_get_default_cclasses()
        {
            var cclasses = new 'ResizableIntegerArray';
            cclasses[0] = 0x2000; // Word/Identifier
            cclasses[1] = 0x0008; // Numeric
            cclasses[2] = 0x0020; // Whitespace
            //cclasses[3] = 0x0400; // Punctuation
            while(1)
                yield(cclasses);
        }

        // From the provided list, determine the first character class that
        // matches the first character in the string
        function private_get_first_cclass(string str, var cclasses [optional], int has_cclasses [opt_flag])
        {
            if (!has_cclasses || cclasses == null)
                cclasses = private_get_default_cclasses();
            int num_classes = elements(cclasses);
            for (int i = 0; i < num_classes; i++) {
                int first_is_cclass = 0;
                int cclass = cclasses[i];
                ${ is_cclass first_is_cclass, cclass, str, 0 };
                if (first_is_cclass)
                    return cclass;
            }
            return 0;
        }
    }

    class CClassTokenizer
    {
        var tokens;
        var data;
        var cclasses;

        function BUILD(var cclasses [optional], int has_cclasses [opt_flag])
        {
            self.tokens = [];
            self.data = null;
            if (has_cclasses)
                self.cclasses = cclasses;
            else
                self.cclasses = null;
        }

        function add_data(string str)
        {
            if (self.data == null)
                self.data = str;
            else {
                string data = self.data;
                self.data = data + str;
            }
        }

        function has_tokens()
        {
            if (elements(self.tokens) > 0)
                return 1;
            if (self.data != null && length(self.data) > 0)
                return 1;
            return 0;
        }

        function get_token()
        {
            if (elements(self.tokens) > 1) {
                string token;
                var tokens = self.tokens;
                ${ shift token, tokens };
                return token;
            }
            if (self.data != null && self.data != "")
                return self.lex_next_token();
            return null;
        }

        function unget_token(string token)
        {
            // Do we want this to go onto the front or the back of the list?
            push(self.tokens, token);
        }

        function lex_next_token()
        {
            string str = self.data;
            int len = length(str);
            int curr_cclass = private_get_first_cclass(str, self.classes);
            if (curr_cclass == 0)
                return self.get_chars(1);
            int next_idx = 0;
            ${ find_not_cclass next_idx, curr_cclass, str, 0, len };
            return self.get_chars(next_idx);
        }

        function get_chars(int count)
        {
            string str = self.data;
            int len = length(str);
            if (count >= len) {
                self.data = null;
                return str;
            }
            self.data = substr(str, count);
            return substr(str, 0, count);
        }
    }
}}
