namespace Rosella { namespace Template { namespace Node
{
    class Logic : Rosella.Template.Node
    {
        var children;
        var logic_name;
        var renderer;

        function Logic(var token)
        {
            using Rosella.String.get_character_class;

            self.Node(token);
            self.children = [];
            var cclasses = [get_character_class("graphical"), get_character_class("whitespace")];
            var tokenizer = new Rosella.String.Tokenizer.CClass(cclasses);
            tokenizer.add_data(token.data());
            self.__parse(tokenizer.all_tokens());
        }

        function __parse(var tokens_raw)
        {
            var tokens = [];
            for (var token in tokens_raw) {
                if (int(token.metadata()) != CCLASS_WHITESPACE)
                    push(tokens, token.data());
            }
            string logic_name;
            ${ shift logic_name, tokens };
            self.logic_name = logic_name;
            switch (logic_name) {
                case "for":
                    self.__parse_for(tokens);
                    break;
                case "if":
                    self.__parse_if(tokens);
                    break;
                case "unless":
                    self.__parse_unless(tokens);
                    break;
                case "include":
                    self.__parse_include(tokens);
                    break;
                default:
                    if (substr(logic_name, 0, 3) != "end") {
                        using Rosella.Error.invalid;
                        invalid(__FUNCTION__, "Unknown logic block '" + logic_name + "'");
                    }
            }
        }

        function logic_name()
        {
            return self.logic_name;
        }

        function logic_end_name()
        {
            return sprintf("end%s", [self.logic_name]);
        }

        function assemble(var parent_nodes, var current_node)
        {
            if (self.is_logic_end() &&
                string(self.logic_name) == string(current_node.logic_end_name()))
                ${ pop current_node, parent_nodes };
            else {
                current_node.add_child(self);
                push(parent_nodes, current_node);
                current_node = self;
            }
            return current_node;
        }

        function is_logic_end()
        {
            string name = self.logic_name;
            if (substr(name, 0, 3) == "end")
                return 1;
            return 0;
        }

        function add_child(var node)
        {
            push(self.children, node);
        }

        function render(var context, var builder)
        {
            var renderer = self.renderer;
            if (renderer == null)
                return;
            renderer(self.children, context, builder);
        }

        const string HASH_KEY_VARNAME = "__KEY__";

        function __parse_for(var tokens)
        {
            if (elements(tokens) != 3 || string(tokens[1]) != "in") {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Syntax of for loop is 'for <var> in <src>'");
            }

            string varname = tokens[0];
            if (varname == HASH_KEY_VARNAME) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Cannot use '" + HASH_KEY_VARNAME + "' as the name of a loop variable");
            }

            string sourcename = tokens[2];
            self.renderer = function(var children, var ctx, var sb) {
                var values = ctx.get_value(sourcename);
                if (values == null) {
                    using Rosella.Error.invalid;
                    invalid(__FUNCTION__, "no value at '" + sourcename + "'");
                }
                int does_hash;
                ${ does does_hash, values, "hash" };
                if (does_hash) {
                    for (string key in values) {
                        var value = values[key];
                        ctx.set_temporary(varname, value);
                        ctx.set_temporary(HASH_KEY_VARNAME, key);
                        for (var child in children)
                            child.render(ctx, sb);
                    }
                } else {
                    ctx.set_temporary(HASH_KEY_VARNAME, "");
                    for (var value in values) {
                        ctx.set_temporary(varname, value);
                        for (var child in children)
                            child.render(ctx, sb);
                    }
                }
            };
        }
    }
}}}
