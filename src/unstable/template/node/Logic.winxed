namespace Rosella { namespace Template { namespace Node
{
    class Logic : Rosella.Template.Node
    {
        var children;
        var logic_name;
        var renderer;

        function Logic(var token)
        {
            self.Node(token);
            self.children = [];
            var parts = [];
            using Rosella.String.Tokenizer.CClass.get_named_classes;
            var cclasses = get_named_classes(["graphical", "whitespace"]);
            var tokenizer = new Rosella.String.Tokenizer.CClass(cclasses);
            string contents = token.data();
            tokenizer.add_data(contents);
            self.__parse(tokenizer.all_tokens());
        }

        function __parse(var tokens_raw)
        {
            var tokens = [];
            for (var token in tokens_raw) {
                if (int(token.metadata()) != CCLASS_WHITESPACE)
                    push(tokens, token.data());
            }
            string logic_name;
            ${ shift logic_name, tokens };
            self.logic_name = logic_name;
            switch (logic_name) {
                case "for":
                    self.__parse_for(tokens);
                    break;
                case "if":
                    self.__parse_if(tokens);
                    break;
                case "unless":
                    self.__parse_unless(tokens);
                    break;
                case "include":
                    self.__parse_include(tokens);
                    break;
                default:
                    if (substr(logic_name, 0, 3) != "end") {
                        using Rosella.Error.invalid;
                        invalid(__FUNCTION__, "Unknown logic block '" + logic_name + "'");
                    }
            }
        }

        function logic_name()
        {
            return self.logic_name;
        }

        function logic_end_name()
        {
            return sprintf("end%s", [self.logic_name]);
        }

        function assemble(var parent_nodes, var current_node)
        {
            if (self.is_logic_end() &&
                string(self.logic_name) == string(current_node.logic_end_name()))
                ${ pop current_node, parent_nodes };
            else {
                current_node.add_child(self);
                push(parent_nodes, current_node);
                current_node = self;
            }
            return current_node;
        }

        function is_logic_end()
        {
            string name = self.logic_name;
            if (substr(name, 0, 3) == "end")
                return 1;
            return 0;
        }

        function add_child(var node)
        {
            push(self.children, node);
        }

        function render(var context, var builder)
        {
            var renderer = self.renderer;
            if (renderer == null)
                return;
            renderer(self.children, context, builder);
        }

        function __parse_for(var tokens)
        {
            string varname = tokens[0];
            string in_text = tokens[1];
            string sourcename = tokens[2];
            var renderer = function(var children, var ctx, var sb) {
                var path = new Rosella.Path();
                var values = path.get(ctx, sourcename);
                for (var value in values) {
                    ctx[varname] = value;
                    for (var child in children)
                        child.render(ctx, sb);
                }
            };
            self.renderer = renderer;
        }
    }
}}}
