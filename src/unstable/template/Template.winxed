namespace Rosella { namespace Template
{
    class Engine
    {
        var tokenizer;
        var eval_count;
        var node_factory;

        function Engine()
        {
            self.tokenizer = new Rosella.String.Tokenizer.DelimiterRegion("LiteralText");
            self.node_factory = new Rosella.Template.NodeFactory();
            self.eval_count = 0;
            self.setup_region_types();
        }

        function setup_region_types()
        {
            self.node_factory.register_type("LiteralRegion", class Rosella.Template.Node.Literal);

            self.tokenizer.add_region("<%", "%>", "EvalRegion");
            self.node_factory.register_type("EvalRegion", class Rosella.Template.Node.Eval);

            self.tokenizer.add_region("<#", "#>", "DataRegion");
            self.node_factory.register_type("DataRegion", class Rosella.Template.Node.Data);

            self.tokenizer.add_region("<$", "$>", "LogicRegion");
            self.node_factory.register_type("LogicRegion", class Rosella.Template.Node.Logic);
        }

        function generate(string tmpl, var context)
        {
            var nodes_array = self.__get_nodes_array(tmpl);
            var node = self.__create_node_tree(nodes_array);
            var builder = new ['StringBuilder'];
            node.render(context, builder);
            return string(builder);
        }

        function __get_nodes_array(string tmpl)
        {
            var nodes_array = [];
            self.tokenizer.add_data(tmpl);
            while (self.tokenizer.has_tokens()) {
                var t = self.tokenizer.next_token();
                var node = self.node_factory.create(t);
                push(nodes_array, node);
            }
            return nodes_array;
        }

        function __create_node_tree(var nodes_array)
        {
            var first_node = new Rosella.Template.Node.Master();
            var current_node = first_node;
            var parent_nodes = [];
            for (var node in nodes_array) {
                string type = node.type();
                switch (type) {
                    case "LiteralText":
                    case "EvalRegion":
                    case "DataRegion":
                        current_node.add_child(node);
                        break;
                    case "LogicRegion":
                        string func = node.logic_name();
                        if (func == string(current_node.logic_end_name()))
                            current_node = pop(parent_nodes);
                        else {
                            push(parent_nodes, current_node);
                            current_node = node;
                        }
                        break;
                    default:
                        using Rosella.Error.invalid;
                        invalid(__FUNCTION__, "Unknown type: " + type);
                        break;
                }
            }
            return first_node;
        }
    }
}}
