namespace Rosella { namespace Template
{
    class Engine
    {
        var tokenizer;
        var eval_count;

        function Engine()
        {
            self.tokenizer = new Rosella.String.Tokenizer.DelimiterRegion("LiteralText");
            self.tokenizer.add_region("<%", "%>", "EvalRegion");
            self.tokenizer.add_region("<#", "#>", "DataRegion");
            self.tokenizer.add_region("<$", "$>", "LogicRegion");
            self.eval_count = 0;
        }

        function generate(string tmpl, var context)
        {
            var nodes_array = self.__get_nodes_array(tmpl)
            var node = self.__create_node_tree(nodes_array);
            var builder = new ['StringBuilder']
            node.render(context, builder);
            return string(builder);
        }

        function __get_nodes_array(string tmpl)
        {
            var nodes_array = [];
            self.tokenizer.add_data(tmpl);
            while (self.tokenizer.has_tokens()) {
                var t = self.tokenizer.next_token();
                string type = node.type();
                var node;
                switch (type) {
                    case "LiteralText":
                        node = new Rosella.Template.Node.Literal(t);
                        break;
                    case "EvalRegion":
                        node = new Rosella.Template.Node.Eval(t);
                        break;
                    case "DataRegion":
                        node = new Rosella.Template.Node.Data(t);
                        break;
                    case "LogicRegion":
                        node = new Rosella.Template.Node.Logic(t);
                        break;
                    default:
                        using Rosella.Error.invalid;
                        invalid(__FUNCTION__, "Unknown type: " + type);
                        break;
                }
                push(nodes_array, node);
            }
            return nodes_array;
        }

        function __create_node_tree(var nodes_array)
        {
            var first_node = new Rosella.Template.Node(null);
            var current_node = first_node
            var parent_nodes = [];
            for (var node in nodes_array) {
                string type = node.type();
                switch (type) {
                    case "LiteralText":
                    case "EvalRegion":
                    case "DataRegion":
                        current_node.add_child(node);
                        break;
                    case "LogicRegion":
                        string func = node.logic_name();
                        if (func == string(current_node.logic_end_name()))
                            current_node = pop(parent_nodes);
                        else {
                            push(parent_nodes, current_node);
                            current_node = node;
                        }
                        break;
                    default:
                        using Rosella.Error.invalid;
                        invalid(__FUNCTION__, "Unknown type: " + type);
                        break;
                }
            }
            return first_node;
        }
    }
}}
