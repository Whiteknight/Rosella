namespace Rosella { namespace Template
{
    class Engine
    {
        const string DEFAULT_REGION_NAME = "!!!LiteralRegion!!!";
        var default_nodeclass;
        var regions;

        function Engine()
        {
            self.default_nodeclass = class Rosella.Template.Node.Literal;
            self.regions = {
                "Eval" : ["<%", "%>", class Rosella.Template.Node.Eval],
                "Data" : ["<#", "#>", class Rosella.Template.Node.Data],
                "Logic" : ["<$", "$>", class Rosella.Template.Node.Logic]
            };
        }

        function setup_region_types(var tokenizer, var node_factory)
        {
            node_factory.register_type(DEFAULT_REGION_NAME, self.default_nodeclass);

            for (string region in self.regions) {
                var region_data = self.regions[region];
                tokenizer.add_region(region_data[0], region_data[1], region);
                node_factory.register_type(region, region_data[2]);
            }
        }

        function add_region(string name, string start, string end, var node_class)
        {
            self.regions[name] = [start, end, node_class];
        }

        function remove_region(string name)
        {
            if (exists self.regions[name])
                delete self.regions[name];
        }

        function set_region_delimiters(string name, string start, string end)
        {
            if (!(exists self.regions[name])) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Region " + name + " not found");
            }
            var region = self.regions[name];
            region[0] = start;
            region[1] = end;
        }

        function set_region_nodeclass(string name, var node_class)
        {
            if (!(exists self.regions[name])) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Region " + name + " not found");
            }
            var region = self.regions[name];
            region[2] = node_class;
        }

        function generate(string tmpl, var user_context)
        {
            var tokenizer = new Rosella.String.Tokenizer.DelimiterRegion(DEFAULT_REGION_NAME);
            var node_factory = new Rosella.Template.Node.Factory();
            self.setup_region_types(tokenizer, node_factory);
            var nodes_array = self.__get_nodes_array(tokenizer, node_factory, tmpl);
            var node = self.__create_node_tree(nodes_array);
            var builder = new ['StringBuilder'];
            var context = new Rosella.Template.Context(user_context);
            node.render(context, builder);
            return string(builder);
        }

        function generate_from_file(string tmpl_filename, var user_context)
        {
            var file = new Rosella.FileSystem.File(tmpl_filename);
            if (!file.exists()) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Template file " + tmpl_filename + " does not exist");
            }
            string tmpl = file.read_all_text();
            self.generate(tmpl, user_context);
        }

        function __get_nodes_array(var tokenizer, var node_factory, string tmpl)
        {
            var nodes_array = [];
            tokenizer.add_data(tmpl);
            while (tokenizer.has_tokens()) {
                var t = tokenizer.get_token();
                var node = node_factory.create(t);
                push(nodes_array, node);
            }
            return nodes_array;
        }

        function __create_node_tree(var nodes_array)
        {
            var first_node = new Rosella.Template.Node.Master();
            var current_node = first_node;
            var parent_nodes = [];
            for (var node in nodes_array)
                current_node = node.assemble(parent_nodes, current_node);
            return first_node;
        }
    }
}}
