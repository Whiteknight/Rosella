namespace Rosella { namespace Query { namespace Provider
{
    /* Array Query Provider
        This provider operates on Array data.
    */
    class Array : Rosella.Query.Provider
    {
        // Constructor
        function Array() {}

        // Return a new array where the elements are all functions of the
        // elements in the current array
        function map(var data, var mapper)
        {
            var new_data = [];
            for (int i = elements(data) - 1; i >= 0; i--)
                new_data[i] = mapper(data[i]);
            return new_data;
        }

        // Return a new array with only the elements from the original array
        // which satisfy the predicate. If provided, only return up to N items
        function filter(var data, var func,
            int limit [optional], int has_limit [opt_flag])
        {
            if (!has_limit)
                limit = elements(data);
            var new_data = [];
            if (limit <= 0)
                return new_data;
            int count = 0;
            for (var item in data) {
                if (func(item)) {
                    push(new_data, item);
                    count = count + 1;
                    if (count >= limit)
                        return new_data;
                }
            }
            return new_data;
        }

        // Return a single result which is a combination of all elements
        function fold(var seed, var data, var func)
        {
            var result = seed;
            if (result == null)
                result = "";
            for (var item in data)
                result = func(result, item);
            return result;
        }

        // Return a new array, the first N items which match the optional
        // predicate
        function take(var data, var limit,
                var func [optional], int has_func [opt_flag])
        {
            if (has_func)
                return self.filter(data, func, limit);
            int count = 0;
            var new_data = [];
            for (var item in data) {
                push(new_data, item);
                count = count + 1;
                if (count > limit)
                    return new_data;
            }
            return new_data;
        }

        // Combine
        function combine(var a, var b,
                var filter [optional], int has_filter [opt_flag],
                var key_func [optional], int has_key_func [opt_flag],
                var dispute [optional], int has_dispute [opt_flag])
        {
            if (has_filter) {
                a = self.filter(a, filter);
                b = self.filter(b, filter);
            }
            if (has_key_func) {
                if (!has_dispute)
                    dispute = function (data_a, data_b) { return data_a; };
                return self.join_key(a, b, key_func, dispute);
            }
            var new_data = [];
            for (var item_a in a)
                push(new_data, item_a);
            for (var item_b in b)
                push(new_data, item_b);
            return new_data;
        }

        function combine_key(var a, var b, var key_func, var dispute)
        {
            var keys = {};
            for (var item_a in a) {
                var key = key_func(item_a);
                if (exists keys[key])
                    keys[key] = dispute(key, keys[key], item_a);
                else
                    keys[key] = item_a;
            }
            for (var item_b in b) {
                var key = key_func(item_b);
                if (exists keys[key])
                    keys[key] = dispute(key, keys[key], item_b);
                else
                    keys[key] = item_b;
            }
            var new_data = [];
            for (string key in keys)
                push(new_data, keys[key]);
            return new_data;
        }

        function unwrap_first(var data)
        {
            return data[0];
        }

        // Return a new array. Clone this one.
        function to_array(var data)
        {
            var new_data = [];
            for (int i = elements(data) - 1; i >= 0; i--)
                new_data[i] = data[i];
            return new_data;
        }

        // Return a new hash. The keys of which are returned from the function
        function to_hash(var data, var func)
        {
            var new_hash = {};
            for (var item in data) {
                string new_key = func(item);
                new_hash[new_key] = item;
            }
            return new_hash;
        }
    }
}}}
