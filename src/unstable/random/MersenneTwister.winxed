class Rosella.Random.MersenneTwister : Rosella.Random.RandomNumber
{
    // Period parameters
    const int N = 624;
    const int M = 397;
    const int MATRIX_A = 0x9908b0df;
    const int UPPER_MASK = 0x80000000; // most significant bit
    const int LOWER_MASK = 0x7FFFFFFF; // the rest

    // Tempering paramters
    const int TEMPERING_MASK_B = 0x9D2C5680;
    const int TEMPERING_MASK_C = 0xEFC60000;

    var mt; // state vector
    var mti; // mti == N + 1 means mt[N] is not initialized
    var mag01;

    function MersenneTwister()
    {
        self.mt = [];
        self.mag01 = [];

        int t;
        ${ time t };
        self.initialize(t);
    }

    function initialize(int seed)
    {
        self.mag01[0] = 0;
        self.mag01[1] = MATRIX_A;

        self.mt[0] = seed & 0xFFFFFFFF;
        for (self.mti = 1; self.mti < N; self.mti++)
        {
            int y = self.mt[self.mti - 1];
            int z;
            ${ lsr z, y, 30 };

            self.mt[self.mti] = 1812433253 * (self.mt[self.mti - 1] ^ z) + self.mti;
            self.mt[self.mti] = self.mt[self.mti] & 0xFFFFFFFF;
        }
    }

    function get()
    {
        int y;
        int z;

        if (self.mti >= N)
        {
            int kk;
            var mt = self.mt;
            var mag01 = self.mag01;

            for (kk = 0; kk < N - M; kk++)
            {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                ${ lsr z, y, 1 };
                mt[kk] = mt[kk + M] ^ z ^ mag01[y & 1];
            }
            for (; kk < N - 1; kk++)
            {
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                ${ lsr z, y, 1 };
                mt[kk] = mt[kk + (M - N)] ^ z ^ mag01[y & 1];
            }

            y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
            ${ lsr z, y, 1 };
            mt[N - 1] = mt[M - 1] ^ z ^ mag01[y & 1];

            self.mti = 0;
        }

        y = self.mt[self.mti];
        self.mti++;

        ${ lsr z, y, 11 };
        y = y ^ z;                                  // TEMPERING_SHIFT_U(y)
        y = y ^ (y << 7) & TEMPERING_MASK_B;        // TEMPERING_SHIFT_S(y)
        y = y ^ (y << 15) & TEMPERING_MASK_C;       // TEMPERING_SHIFT_L(y)
        ${ lsr z, y, 18 };
        y = y ^ z;                                  // TEMPERING_SHIFT_T(y)

        return y;
    }

    function get_float()
    {
        float n = (1 << 24);
        int y = self.get();
        ${ lsr y, y, 8 };

        return y / n;
    }
}

