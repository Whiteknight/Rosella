class Rosella.Xml.Tag
{
    var attributes;
    var children;
    var xmlns;
    var name;
    var end_tag;
    var pos;

    function Tag(int pos, string xmlns, string name)
    {
        self.pos = pos;
        self.xmlns = xmlns;
        self.name = name;
        self.attributes = {};
        self.children = [];
    }

    function add_attribute(string name, string value)
    {
        self.attributes[name] = value;
    }

    function add_child(var child)
    {
        push(self.children, child);
    }

    function add_child_text(string text)
    {
        text = Rosella.String.trim(text);
        if (text != null && text != "")
            self.add_child(new Rosella.Xml.Text(text));
    }

    function set_end(var end_tag)
    {
        self.end_tag = end_tag;
    }

    function to_xml()
    {
        var sb = new 'StringBuilder';
        self.to_xml_sb(sb, 0);
        return sb;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<");
        string ns = self.xmlns;
        if (ns != "") {
            push(sb, ns);
            push(sb, ":");
        }
        push(sb, self.name);
        self.__to_xml_sb_attrs(sb, indent);
        push(sb, ">");
        self.__to_xml_sb_children(sb, indent + 1);

        push(sb, indent_str);
        push(sb, "</");
        if (ns != "") {
            push(sb, ns);
            push(sb, ":");
        }
        push(sb, self.name);
        push(sb, ">");
    }

    function __to_xml_sb_attrs(var sb, int indent)
    {
        for (string attr_name in self.attributes) {
            string attr = self.attributes[attr_name];
            push(sb, " ");
            push(sb, attr_name);
            push(sb, "='");
            push(sb, attr);
            push(sb, "'");
        }
    }

    function __to_xml_sb_children(var sb, int indent)
    {
        for (var child in self.children)
            child.to_xml_sb(sb, indent);
    }
}

class Rosella.Xml.Tag.EndTag : Rosella.Xml.Tag
{
    var xmlns;
    var name;
    var pos;

    function EndTag(int pos, string xmlns, string name)
    {
        self.pos = pos;
        self.xmlns = xmlns;
        self.name = name;
    }

    function add_attribute(string name, string value) { Rosella.Error.error("End tags do not have attributes"); }

    function add_child(var child) { Rosella.Error.error("End tags do not have children"); }

    function add_child_text(string text) { Rosella.Error.error("End tags do not contain text"); }

    function set_end(var end_tag) { Rosella.Error.error("End tags do not have end tags"); }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "</");
        string xmlns = self.xmlns;
        if (xmlns != "") {
            push(sb, xmlns);
            push(sb, ":");
        }
        push(sb, self.name);
        push(sb, ">");
    }
}

class Rosella.Xml.Tag.XmlHeader : Rosella.Xml.Tag
{
    function XmlHeader(int pos) { self.Tag(pos, "", "?xml"); }

    function to_xml_sb(var sb, int indent)
    {
        push(sb, "<?xml ");
        self.__to_xml_sb_attrs(sb, indent);
        push(sb, "?>");
    }

    function add_child(var child)
    {
        Rosella.Error.error("XML Header tags do not have child tags");
    }

    function add_child_text(string text)
    {
        Rosella.Error.error("XML Header tags may not contain raw text");
    }

    function set_end(var end_tag)
    {
        Rosella.Error.error("XML Header tags do not have closing tags");
    }
}


// TODO: The DtdHeader should generate a DtdDocument. If a path is given it
// should load the document from the path. If inline tags are given, it should
// use them instead. If both, standard rules for scoping apply.
class Rosella.Xml.Tag.DtdHeader : Rosella.Xml.Tag
{
    var dtd_document;
    var doctype;
    var scope;
    var filename;

    function DtdHeader(int pos, string doctype)
    {
        self.doctype = doctype;
        self.Tag(pos, "", "!DOCTYPE");
    }

    function get_dtd_document()
    {
        if (self.dtd_document != null)
            return self.dtd_document;
        string scope = self.scope;
        var dtd_document;
        // TODO: If we have a SYSTEM or PUBLIC DTD, the <?xml ?> header should have
        // a standalone="no" attribute
        switch (scope) {
            case "SYSTEM":
                dtd_document = Rosella.Xml.read_dtd_file(self.filename);
                break;
            case "PUBLIC":
                // TODO: This is online somewhere, go fetch it
                Rosella.Error.not_implemented(__FUNCTION__ + " PUBLIC");
            default:
                dtd_document = new Rosella.Xml.DtdDocument();
                break;
        }
        self.dtd_document = dtd_document;
        return dtd_document;
    }

    function set_scope(string scope, string filename)
    {
        self.scope = scope;
        self.filename = filename;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!DOCTYPE ");
        push(sb, self.doctype);
        push(sb, " ");
        string scope = self.scope;
        push(sb, scope);
        push(sb, " ");
        switch (scope) {
            case "SYSTEM":
                push(sb, "'");
                push(sb, self.filename);
                push(sb, "'");
                break;
            case "PUBLIC":
                push(sb, "'");
                push(sb, self.filename);
                push(sb, "'");
                // TODO: The rest of it
                break;
        }
        if (self.dtd_document != null) {
            push(sb, " [");
            self.dtd_document.to_xml_sb(sb, indent + 1);
            push(sb, indent_str);
            push(sb, "]");
        } else
            push(sb, indent_str);
        push(sb, ">");
    }

    function add_child(var child)
    {
        Rosella.Error.error("Inline DTD do not contain children");
    }

    function add_child_text(string text)
    {
        Rosella.Error.error("DTD Header tags may not contain raw text");
    }

    function set_end(var end_tag)
    {
        Rosella.Error.error("DTD Header tags do not have closing tags");
    }
}

class Rosella.Xml.Tag.DtdElement
{
    var children;
    var children_rule;
    var attlist;
    var name;
    var pos;

    function DtdElement(int pos, string name)
    {
        self.pos = pos;
        self.children = {};
        self.name = name;
    }

    function add_child_type(string name, string modifier)
    {
        // TODO: Handle #CDATA and #PCDATA specially.
        self.children[name] = modifier;
    }

    function add_attribute(string attrname, string attrtype, string default_value, string default_rule, string fixed_value)
    {
        if (self.attlist == null)
            self.attlist = new Rosella.Xml.Tag.DtdAttlist(self.name);
        self.attlist.add_attr(attrname, attrtype, default_value, default_rule, fixed_value);
    }

    function set_child_rule(string rule)
    {
        self.children_rule = rule;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!ELEMENT ");
        push(sb, self.name);
        push(sb, " (");
        string separator = "";
        for (string child in self.children) {
            push(sb, separator);
            push(sb, child);
            push(sb, self.children[child]);
            separator = ",";
        }
        push(sb, ")>");
        for (var attr in self.attributes)
            attr.to_xml_sb(sb, indent);
    }
}

class Rosella.Xml.Tag.DtdAttlist
{
    var elemname;
    var attrnames;
    var attrtypes;
    var default_values;
    var default_rules;
    var fixed_values;

    function DtdAttlist(string elemname)
    {
        self.elemname = elemname;
        self.attrtypes = []; // This might need to be non-string for enumerated types

        string attrnames[] = [];
        self.attrnames = attrnames;

        string default_values[] = [];
        self.default_values = default_values;

        string default_rules[] = [];
        self.default_rules = default_rules;

        string fixed_values[] = [];
        self.fixed_values = fixed_values;
    }

    function add_attr(string attrname, string typename, string default_value, string default_rule, string fixed_value)
    {
        push(self.attrnames, attrname);

        // TODO: Validate against a list of possible types:
        // CDATA, ID, IDREF, IDREFS, NMTOKEN, NMTOKENS, ENTITY, ENTITIES, NOTATION
        // or an alternation "(foo|bar|baz)" of these things.
        push(self.attrtypes, typename);
        push(self.default_values, default_value);

        switch (default_rule) {
            case "REQUIRED":
            case "IMPLIED":
            case "FIXED":
            case "":
                break;
            default:
                Rosella.Error.error("ATTLIST default rule must be one of REQUIRED IMPLIED or FIXED ('%s')", default_rule);
        }
        push(self.fixed_values, fixed_value);
        push(self.default_rules, default_rule);
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!ATTLIST ");
        push(sb, self.elemname);
        for (int i = 0; i < elements(self.attrnames); i++) {
            push(sb, " ");
            push(sb, self.attrnames[i]);
            push(sb, " ");
            push(sb, self.attrtypes[i]);
            string default_value = self.default_values[i];
            if (default_value != null && default_value != "") {
                push(sb, " '");
                push(sb, default_value);
                push(sb, "'");
            }
            string default_rule = self.default_rules[i];
            if (default_rule != null && default_rule != "") {
                push(sb, " #");
                push(sb, default_rule);
                if (default_rule == "FIXED") {
                    push(sb, " '");
                    string fixed_value = self.fixed_values[i];
                    push(sb, fixed_value);
                    push(sb, "'");
                }
            }
        }
        // TODO: The rest of it
        push(sb, ">");
    }
}

class Rosella.Xml.Tag.Comment
{
    var text;
    var pos;

    function Comment(int pos, string comment_text)
    {
        self.text = comment_text;
        self.pos;
    }

    function to_xml()
    {
        var sb = new 'StringBuilder';
        self.to_xml_sb(sb, 0);
        return sb;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!--");
        push(sb, self.text);
        push(sb, "-->");
    }
}

class Rosella.Xml.Tag.DocumentRoot : Rosella.Xml.Tag
{
    function DocumentRoot() { self.children = []; }
}
