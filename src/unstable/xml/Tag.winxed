class Rosella.Xml.Tag
{
    var attributes;
    var children;
    var xmlns;
    var name;
    var end_tag;
    var pos;

    function Tag(int pos, string xmlns, string name)
    {
        self.pos = pos;
        self.xmlns = xmlns;
        self.name = name;
        self.attributes = {};
        self.children = [];
    }

    function add_attribute(string name, string value)
    {
        self.attributes[name] = value;
    }

    function add_child(var child)
    {
        push(self.children, child);
    }

    function add_child_text(string text)
    {
        text = Rosella.String.trim(text);
        if (text != null && text != "")
            self.add_child(new Rosella.Xml.Text(text));
    }

    function set_end(var end_tag)
    {
        self.end_tag = end_tag;
    }

    function to_xml()
    {
        var sb = new 'StringBuilder';
        self.to_xml_sb(sb, 0);
        return sb;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<");
        string ns = self.xmlns;
        if (ns != "") {
            push(sb, ns);
            push(sb, ":");
        }
        push(sb, self.name);
        self.__to_xml_sb_attrs(sb, indent);
        push(sb, ">");
        self.__to_xml_sb_children(sb, indent + 1);

        push(sb, indent_str);
        push(sb, "</");
        if (ns != "") {
            push(sb, ns);
            push(sb, ":");
        }
        push(sb, self.name);
        push(sb, ">");
    }

    function __to_xml_sb_attrs(var sb, int indent)
    {
        for (string attr_name in self.attributes) {
            string attr = self.attributes[attr_name];
            push(sb, " ");
            push(sb, attr_name);
            push(sb, "='");
            push(sb, attr);
            push(sb, "'");
        }
    }

    function __to_xml_sb_children(var sb, int indent)
    {
        for (var child in self.children)
            child.to_xml_sb(sb, indent);
    }
}

class Rosella.Xml.Tag.EndTag : Rosella.Xml.Tag
{
    var xmlns;
    var name;
    var pos;

    function EndTag(int pos, string xmlns, string name)
    {
        self.pos = pos;
        self.xmlns = xmlns;
        self.name = name;
    }

    function add_attribute(string name, string value) { Rosella.Error.error("End tags do not have attributes"); }

    function add_child(var child) { Rosella.Error.error("End tags do not have children"); }

    function add_child_text(string text) { Rosella.Error.error("End tags do not contain text"); }

    function set_end(var end_tag) { Rosella.Error.error("End tags do not have end tags"); }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "</");
        string xmlns = self.xmlns;
        if (xmlns != "") {
            push(sb, xmlns);
            push(sb, ":");
        }
        push(sb, self.name);
        push(sb, ">");
    }
}

class Rosella.Xml.Tag.XmlHeader : Rosella.Xml.Tag
{
    function XmlHeader(int pos) { self.Tag(pos, "", "?xml"); }

    function to_xml_sb(var sb, int indent)
    {
        push(sb, "<?xml ");
        self.__to_xml_sb_attrs(sb);
        push(sb, "?>");
    }

    function add_child(var child)
    {
        Rosella.Error.error("XML Header tags do not have child tags");
    }

    function add_child_text(string text)
    {
        Rosella.Error.error("XML Header tags may not contain raw text");
    }

    function set_end(var end_tag)
    {
        Rosella.Error.error("XML Header tags do not have closing tags");
    }
}


// TODO: The DtdHeader should generate a DtdDocument. If a path is given it
// should load the document from the path. If inline tags are given, it should
// use them instead. If both, standard rules for scoping apply.
class Rosella.Xml.Tag.DtdHeader : Rosella.Xml.Tag
{
    var dtd_document;
    var doctype;
    var scope;
    var filename;

    function DtdHeader(int pos, string doctype)
    {
        self.doctype = doctype;
        self.Tag(pos, "", "!DOCTYPE");
    }

    function get_dtd_document()
    {
        if (self.dtd_document != null)
            return self.dtd_document;
        string scope = self.scope;
        string dtd_document;
        // TODO: If we have a SYSTEM or PUBLIC DTD, the <?xml ?> header should have
        // a standalone="no" attribute
        switch (scope) {
            case "SYSTEM":
                dtd_document = Rosella.Xml.read_dtd_file(self.filename);
                break;
            case "PUBLIC":
                // TODO: This is online somewhere, go fetch it
                Rosella.Error.not_implemented(__FUNCTION__ + " PUBLIC");
            default:
                dtd_document = new Rosella.Xml.DtdDocument();
                break;
        }
        self.dtd_document = dtd_document;
        return dtd_document;
    }

    function set_scope(string scope, string filename)
    {
        self.scope = scope;
        self.filename = filename;
    }

    function to_xml_sb(var sb, int indent)
    {
        push(sb, "<!DOCTYPE ");
        push(sb, self.doctype);
        push(sb, " ");
        string scope = self.scope;
        push(sb, scope);
        push(sb, " ");
        switch (scope) {
            case "SYSTEM":
                push(sb, "'");
                push(sb, self.filename);
                push(sb, "'");
                break;
            case "PUBLIC":
                push(sb, "'");
                push(sb, self.filename);
                push(sb, "'");
                // TODO: The rest of it
                break;
        }
        if (self.dtd_document != null) {
            push(sb, " [");
            self.dtd_document.to_xml(sb);
            push(sb, "]");
        }
        push(sb, ">");
    }

    function add_child(var child)
    {
        Rosella.Error.error("Inline DTD do not contain children");
    }

    function add_child_text(string text)
    {
        Rosella.Error.error("DTD Header tags may not contain raw text");
    }

    function set_end(var end_tag)
    {
        Rosella.Error.error("DTD Header tags do not have closing tags");
    }
}

class Rosella.Xml.Tag.DtdElement
{
    var children;
    var children_rule;
    var attributes;
    var name;
    var pos;

    function DtdElement(int pos, string name)
    {
        self.pos = pos;
        self.children = {};
        self.attributes = {};
        self.name = name;
    }

    function add_child_type(string name, string modifier)
    {
        // TODO: Handle #CDATA and #PCDATA specially.
        self.children[name] = modifier;
    }

    function add_attribute(string name, var attr)
    {
        self.attributes[name] = attr;
    }

    function set_attribute_default_value(string attrname, string value)
    {
        if (!(exists self.attributes[attrname]))
            Rosella.Error.error("Cannot set attribute default value '%s' on non-existant attribute '%s'", value, attrname);
        // TODO : Keep track of the default value somehow
    }

    function set_child_rule(string rule)
    {
        self.children_rule = rule;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!ELEMENT ");
        push(sb, self.name);
        // TODO: The rest of it
        push(sb, ">\n");
        for (var attr in self.attributes)
            attr.to_xml_sb(sb, indent);
    }
}

class Rosella.Xml.Tag.DtdAttlist
{
    var name;
    var elemname;
    var type;
    var default_value;
    var default_rule;
    var pos;

    function DtdAttlist(int pos, string elemname, string name)
    {
        self.pos = pos;
        self.name = name;
        self.elemname = elemname;
    }

    function set_type(string type)
    {
        // TODO: Validate against a list of possible types:
        // CDATA, ID, IDREF, IDREFS, NMTOKEN, NMTOKENS, ENTITY, ENTITIES, NOTATION
        // or an alternation "(foo|bar|baz)" of these things.
        self.type = type;
    }

    function set_default_value(string default_value)
    {
        self.default_value = default_value;
    }

    function set_default_rule(string default_rule)
    {
        switch (default_rule) {
            case "REQUIRED":
            case "IMPLIED":
            case "FIXED":
                break;
            default:
                Rosella.Error.error("ATTLIST default rule must be one of REQUIRED IMPLIED or FIXED");
        }
        self.default_rule = default_rule;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!ATTLIST ");
        push(sb, self.elemname);
        push(sb, " ");
        push(sb, self.name);
        // TODO: The rest of it
        push(sb, ">\n");
    }
}

class Rosella.Xml.Tag.Comment
{
    var text;
    var pos;

    function Comment(int pos, string comment_text)
    {
        self.text = comment_text;
        self.pos;
    }

    function to_xml()
    {
        var sb = new 'StringBuilder';
        self.to_xml_sb(sb, 0);
        return sb;
    }

    function to_xml_sb(var sb, int indent)
    {
        string indent_str = indent_level(indent);
        push(sb, indent_str);
        push(sb, "<!--");
        push(sb, self.text);
        push(sb, "-->");
    }
}

class Rosella.Xml.Tag.DocumentRoot : Rosella.Xml.Tag
{
    function DocumentRoot() { self.children = []; }

}
