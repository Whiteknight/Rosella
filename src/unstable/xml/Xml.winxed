namespace Rosella.Xml
{
    function read_file(string filename)
    {
        var document = new Rosella.Xml.Document();
        document.read_from_file(filename);
        return document;
    }

    function read_string(string xml)
    {
        var document = new Rosella.Xml.Document();
        document.read_from_string(xml);
        return document;
    }

    function parse(string xml, var document)
    {
        int len = length(xml);
        var b = get_iterator(var(xml));
        int s[] = [];
        return __parse_xml(xml, s, b, len, document);
    }

    function __parse_frontmatter(string xml, var s, var b, int len, var document)
    {
        while(have_more_chars(s, b)) {
            eat_whitespace(s, b);
            int c = get_next(s, b);
            if (c != ASCII_LESS_THAN)
                Rosella.Error.error("Unexpected token in XML frontmatter: '%s'", chr(c));
            c = get_next(s, b);
            if (c == ASCII_QUESTION_MARK) {
                Rosella.Xml.__parse_xml_header(xml, s, b, len, document);
                continue;
            }
            if (c == ASCII_EXCLAMATION_POINT) {
                c = peek_next(s, b);
                if (c == ASCII_DASH) {
                    // TODO: We shouldn't just discard this
                    Rosella.Xml.__parse_comment(xml, s, b, len);
                    continue;
                }
                if (c == ASCII_D) {
                    Rosella.Xml.__parse_dtd_header(xml, s, b, len, document);
                    continue;
                }
            }

            // If we don't have a <!-- comment, <?xml header or <!DOCTYPE, return and
            // let the main loop parse it.
            unshift_int(s, c);
            unshift_int(s, ASCII_LESS_THAN);
            return;
        }
    }

    function __parse_xml(string xml, var s, var b, int len, var document)
    {
        var tag_stack = [];
        var current_tag = null;

        eat_whitespace(s, b);

        Rosella.Xml.__parse_frontmatter(xml, s, b, len, document);

        int c;
        while(have_more_chars(s, b)) {
            eat_whitespace(s, b);
            c = get_next(s, b);
            if (c == ASCII_LESS_THAN) {
                :(var tag, int is_close, int contained, int is_comment) = Rosella.Xml.__parse_tag(xml, s, b, len);

                if (is_comment) {
                    // TODO: What do we do about comments appearing before and
                    // after the root node?
                    if (current_tag != null)
                        current_tag.add_child(tag);
                    continue;
                }

                // A self-contained tag: <foo />
                if (contained) {
                    if (current_tag != null)
                        current_tag.add_child(tag);
                    else {
                        current_tag = tag;
                        document.set_root(tag);
                    }
                    continue;
                }

                // A closing tag: </foo>
                if (is_close) {
                    if (current_tag == null)
                        Rosella.Error.error("Syntax error. Found closing tag '%s' without corresponding open tag", tag.name);
                    current_tag.set_end(tag);
                    current_tag = tag_stack.pop();
                    continue;
                }

                // An opening tag: <foo ...>
                if (current_tag != null)
                    current_tag.add_child(tag);
                else
                    document.set_root(tag);
                push(tag_stack, current_tag);
                current_tag = tag;
                continue;
            }
            var sb = new 'StringBuilder';
            while(have_more_chars(s, b) && c != ASCII_LESS_THAN) {
                push(sb, chr(c));
                c = get_next(s, b);
            }

            if (!have_more_chars(s, b))
                break;

            unshift_int(s, c);
            string str = string(sb);
            if (current_tag != null)
                current_tag.add_child_text(str);
        }
        return document;
    }

    // TODO: If available, read the encoding attribute and compare to the
    // encoding that the string is being read as.
    function __parse_xml_header(string xml, var s, var b, int len, var document)
    {
        eat_whitespace(s, b);
        string tag_name = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
        if (tag_name != "xml")
            Rosella.Error.error("Malformed XML header. Should start with '<?xml ... ?>'");

        var header_tag = new Rosella.Xml.Tag.XmlHeader();
        eat_whitespace(s, b);
        Rosella.Xml.__parse_attributes(xml, s, b, len, header_tag);
        eat_whitespace(s, b);
        int c = get_next(s, b);
        if (c == ASCII_QUESTION_MARK) {
            c = get_next(s, b);
            if (c == ASCII_GREATER_THAN) {
                document.set_header(header_tag);
                return;
            }
            unshift_int(s, c);
        }
        Rosella.Error.error("Malformed XML Header tag: '%s'", chr(c));
    }

    function __parse_dtd_header(string xml, var s, var b, int len, var document)
    {
        string tagname = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
        if (tagname != "DOCTYPE")
            Rosella.Error.error("Invalid DOCTYPE tag");
        eat_whitespace(s, b);

        string doctype = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
        eat_whitespace(s, b);

        // Should be one of SYSTEM, PUBLIC, etc
        string dtd_scope = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
        eat_whitespace(s, b);
        int c = get_next(s, b);
        if (c == ASCII_SINGLE_QUOTE || c == ASCII_DOUBLE_QUOTE) {
            string filename = Rosella.Xml.__parse_quoted(c, xml, s, b, len);
        } else if (c == ASCII_OPEN_BRACKET) {
            // TODO: Parse the inline DTD definitions
            Rosella.Error.not_implemented("Cannot parse inline DOCTYPE yet!");
        }
        eat_whitespace(s, b);
        c = get_next(s, b);
        if (c != ASCII_GREATER_THAN)
            Rosella.Error.error("Unknown token in DOCTYPE header: '%s'", chr(c));
    }

    function __parse_tag(string xml, var s, var b, int len)
    {
        // TODO: Namespaces (<foo:bar ...> </foo:bar>)
        eat_whitespace(s, b);
        int c = get_next(s, b);
        if (c == ASCII_EXCLAMATION_POINT)
            return Rosella.Xml.__parse_comment(xml, s, b, len);
        int is_close_tag = false;

        if (c == ASCII_SLASH) {
            c = get_next(s, b);
            is_close_tag = true;
        }
        unshift_int(s, c);
        string tag_name = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
        //if (is_close_tag)
            //tag_name = "/" + tag_name;
        var xtag = new Rosella.Xml.Tag(tag_name);

        eat_whitespace(s, b);
        if (!is_close_tag)
            Rosella.Xml.__parse_attributes(xml, s, b, len, xtag);

        c = get_next(s, b);
        if (c == ASCII_GREATER_THAN)
            return xtag, is_close_tag, false, false;

        if (c == ASCII_SLASH) {
            int next = get_next(s, b);
            if (next == ASCII_GREATER_THAN)
                return xtag, false, true, false;
            else
                Rosella.Error.error("Syntax error in tag %s", tag_name);
        }

        Rosella.Error.error("Syntax error, unknown character '%s' in tag '%s'", chr(c), tag_name);
    }

    function __parse_comment(string xml, var s, var b, int len)
    {
        if (get_next(s, b) != ASCII_DASH || get_next(s, b) != ASCII_DASH)
            Rosella.Error.error("Malformed comment");

        var sb = new 'StringBuilder';
        while (have_more_chars(s, b)) {
            int c = get_next(s, b);

            if (c == ASCII_DASH) {
                int d = get_next(s, b);
                if (d == ASCII_DASH) {
                    int e = get_next(s, b);
                    if (e == ASCII_GREATER_THAN) {
                        string text = string(sb);
                        var comment = new Rosella.Xml.Tag.Comment(text);
                        return comment, true, true, true;
                    }
                    unshift_int(s, e);
                }
                unshift_int(s, d);
            }
            push(sb, chr(c));
        }
        Rosella.Error.error("Unterminated comment at end of document");
    }

    function __parse_attributes(string xml, var s, var b, int len, var xtag)
    {
        while (have_more_chars(s, b)) {
            eat_whitespace(s, b);
            int c = peek_next(s, b);
            if (!is_name_char(c))
                break;

            string attr_name = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
            eat_whitespace(s, b);

            c = get_next(s, b);
            if (c != ASCII_EQUALS) {
                unshift_int(s, c);
                xtag.add_attribute(attr_name, "true");
                eat_whitespace(s, b);
                continue;
            }

            c = get_next(s, b);
            if (c == ASCII_SINGLE_QUOTE || c == ASCII_DOUBLE_QUOTE) {
                string attr_value = Rosella.Xml.__parse_quoted(c, xml, s, b, len);
                xtag.add_attribute(attr_name, attr_value);
            } else {
                unshift_int(s, c);
                string attr_value = Rosella.Xml.__parse_alphanumeric(xml, s, b, len);
                xtag.add_attribute(attr_name, attr_value);
            }
        }
    }

    function __parse_alphanumeric(string xml, var s, var b, int len)
    {
        var sb = new 'StringBuilder';
        int c = get_next(s, b);
        while(have_more_chars(s, b) && is_name_char(c)) {
            push(sb, chr(c));
            c = get_next(s, b);
        }
        unshift_int(s, c);
        string result = string(sb);
        return result;
    }

    function __parse_quoted(int q, string xml, var s, var b, int len)
    {
        var sb = new 'StringBuilder';
        int c = get_next(s, b);
        while (c != q) {
            push(sb, chr(c));
            if (c == ASCII_SLASH) {
                c = get_next(s, b);
                push(sb, chr(c));
            }
            c = get_next(s, b);
        }
        return sb;
    }
}
