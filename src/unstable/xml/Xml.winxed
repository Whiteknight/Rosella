namespace Rosella.Xml
{
    function __capture_alphanumeric(var buffer, int start_idx)
    {
        int end_idx = start_idx;
        int c = buffer[start_idx];
        while(is_alphanumeric(c)) {
            end_idx++;
            c = buffer[end_idx];
        }
        string result = buffer.get_chars(start_idx, end_idx - start_idx, "ascii");
        return result, end_idx;
    }
}

namespace Rosella.Xml
{
    function read_file(string filename)
    {
        var document = new Rosella.Xml.Document();
        document.read_from_file(filename);
        return document;
    }

    function read_string(string xml)
    {
        var document = new Rosella.Xml.Document();
        document.read_from_string(xml);
        return document;
    }

    function parse(string xml, var document)
    {
        var buffer = new 'ByteBuffer';
        buffer =: xml;
        int buf_length = elements(buffer);
        var tag_stack = [];
        var current_tag = null;

        int i = eat_whitespace(buffer, 0);
        int c = buffer[i];
        if (buf_length > 5 && c == ASCII_LESS_THAN && int(buffer[i + 1]) == ASCII_QUESTION_MARK)
            i = Rosella.Xml.__parse_xml_header(buffer, i + 2, document);

        error_on_out_of_bounds(c, buffer, i);
        for ( ; i < elements(buffer); ) {
            int c = buffer[i];
            if (c == ASCII_LESS_THAN) {
                :(var tag, i, int is_close, int contained, int is_comment) = Rosella.Xml.__parse_tag(buffer, i + 1, current_tag);

                // A closing tag: </foo>
                if (!is_comment && !contained && is_close) {
                    if (current_tag == null)
                        Rosella.Error.error("Syntax error. Found closing tag '%s' without corresponding open tag", tag.name);
                    current_tag.set_end(tag);
                    current_tag = tag_stack.pop();
                }
                else
                    document.add_tag(tag);

                // A self-contained tag: <foo />
                if (contained) {
                    if (current_tag != null)
                        current_tag.add_child(tag);
                }

                // An opening tag: <foo ...>
                else if (!is_close) {
                    if (current_tag != null)
                        current_tag.add_child(tag);
                    push(tag_stack, current_tag);
                    current_tag = tag;
                }
                continue;
            }
            i = eat_whitespace(buffer, i);
            int j = i;
            while(j < buf_length && c != ASCII_LESS_THAN) {
                c = buffer[j];
                j++;
            }
            if (j >= buf_length)
                break;
            if (j - i - 2 > 0 && current_tag != null) {
                string content = buffer.get_chars(i + 1, j - i - 2, "ascii");
                current_tag.add_child_text(content);
            }
            i = j - 1;
        }
        return document;
    }

    function __parse_xml_header(var buffer, int i, var document)
    {
        // TODO: Headers are usually like <?xml ... ?>. We aren't reading the "xml"
        // TODO: If available, read the encoding attribute. Use that for parsing the
        // rest of the document.
        var header_tag = new Rosella.Xml.Tag.XmlHeader();
        i = eat_whitespace(buffer, i);
        i = Rosella.Xml.__parse_attributes(buffer, i, header_tag);
        i = eat_whitespace(buffer, i);
        int c = buffer[i];
        if (c == ASCII_QUESTION_MARK && int(buffer[i + 1]) == ASCII_GREATER_THAN) {
            document.set_header(header_tag);
            return i + 2;
        }
        Rosella.Error.error("Malformed XML Header tag");
    }

    function __parse_tag(var buffer, int i, var current_tag)
    {
        // TODO: Namespaces (<foo:bar ...> </foo:bar>)
        i = eat_whitespace(buffer, i);
        int j = i;
        int c = buffer[j];
        if (c == ASCII_EXCLAMATION_POINT)
            return Rosella.Xml.__parse_comment(buffer, i + 1);
        int is_close_tag = false;

        if (c == ASCII_SLASH) {
            j++;
            c = buffer[j];
            is_close_tag = true;
        }

        :(string tag_name, j) = Rosella.Xml.__capture_alphanumeric(buffer, j);
        //if (is_close_tag)
            //tag_name = "/" + tag_name;
        var tag = new Rosella.Xml.Tag(tag_name);

        j = eat_whitespace(buffer, j);
        if (!is_close_tag)
            j = Rosella.Xml.__parse_attributes(buffer, j, tag);

        c = buffer[j];
        if (c == ASCII_GREATER_THAN)
            return tag, j, is_close_tag, false, false;

        if (c == ASCII_SLASH) {
            int next = buffer[j + 1];
            if (next == ASCII_GREATER_THAN)
                return tag, j + 2, false, true, false;
            else
                Rosella.Error.error("Syntax error at position %d", j);
        }

        Rosella.Error.error("Syntax error, unknown character '%s' at position %d", chr(c), j);
    }

    function __parse_comment(var buffer, int i)
    {
        int buf_len = elements(buffer);

        if (int(buffer[i]) != ASCII_DASH || int(buffer[i+1]) != ASCII_DASH)
            Rosella.Error.error("Malformed comment at position %d", i);

        i = i + 2;
        int j = i;
        int c = buffer[j];
        while (j < buf_len) {
            j++;
            c = buffer[j];
            if (c == ASCII_DASH &&
                int(buffer[j + 1]) == ASCII_DASH &&
                int(buffer[j + 2]) == ASCII_GREATER_THAN) {

                string text = buffer.get_chars(i, j - i, "ascii");
                var comment = new Rosella.Xml.Tag.Comment(text);
                return comment, j + 3, true, true, true;
            }
        }
        Rosella.Error.error("Unterminated comment starting at position %d", i - 2);
    }

    function __parse_attributes(var buffer, int i, var tag)
    {
        int j = i;
        int c = buffer[j];
        while (is_alphanumeric(c)) {
            :(string attr_name, j) = Rosella.Xml.__capture_alphanumeric(buffer, j);
            j = eat_whitespace(buffer, j);

            c = buffer[j];
            if (c != ASCII_EQUALS) {
                tag.add_attribute(attr_name, "true");
                j = eat_whitespace(buffer, j);
                c = buffer[j];
                continue;
            }
            j++;
            c = buffer[j];
            if (c == ASCII_SINGLE_QUOTE || c == ASCII_DOUBLE_QUOTE) {
                int quote = c;
                j++;
                int start_quotes = j;
                c = buffer[j];
                while (c != quote) {
                    if (c == ASCII_SLASH)
                        j += 2;
                    else
                        j++;
                    c = buffer[j];
                }
                int end_quotes = j;
                j++;
                string attr_value = buffer.get_chars(start_quotes, end_quotes - start_quotes, "ascii");
                tag.add_attribute(attr_name, attr_value);
                j = eat_whitespace(buffer, j);
            } else {
                :(string attr_value, j) = Rosella.Xml.__capture_alphanumeric(buffer, j);
                tag.add_attribute(attr_name, attr_value);
                j = eat_whitespace(buffer, j);
            }
            c = buffer[j];
        }
        error_on_out_of_bounds(c, buffer, i);
        return j;
    }
}

