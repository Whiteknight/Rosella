namespace Rosella.Container
{
}

class Rosella.Container
{
    var type_registry;
    var aliases;

    function Container()
    {
        var reg = {};
        reg.set_key_type(3);
        self.type_registry = reg;
        self.aliases = {};
    }

    function sort_options(var options)
    {
        var resolver = null;
        var build_options = [];
        var misc_options = [];
        for (var option in options) {
            if (!(option instanceof Rosella.Container.Option)) {
                if (resolver != null)
                    self.multiple_resolvers_error(type);
                // it's an instance
                resolver = new Rosella.Container.Resolver.Instance(option);
                continue;
            }
            if (option instanceof Rosella.Container.Option.Create) {
                if (resolver != null)
                    self.multiple_resolvers_error(type);
                resolver = option.get_resolver();
                continue;
            }
            if (option instanceof Rosella.Container.Option.Build) {
                push(build_options, option);
                continue;
            }
            if (option instanceof Rosella.Container.Option) {
                push(misc_options, option);
                continue;
            }
            Rosella.Error.invalid(__FUNCTION__, "Invalid option: %s", typeof(option));
        }
        return resolver, build_options, misc_options;
    }

    function register(var type, var options [slurpy])
    {
        var type_class = Rosella.get_type_class(type);
        if (type_class == null)
            Rosella.Error.invalid(__FUNCTION__, "Attempt to register invalid or null type");
        :(var resolver, var build_options, var misc_options) = self.sort_options(options);
        if (resolver == null)
            resolver = new Rosella.Container.Resolver.Type(type);
        resolver.set_options(build_options, misc_options);
        if (exists self.type_registry[type_class])
            resolver.previous(self.type_registry[type_class]);
        self.type_registry[type_class] = resolver;
        return self;
    }

    function unregister(var type)
    {
        var type_class = Rosella.get_type_class(type);
        if (exists self.type_registry[type_class]) {
            var old = self.type_registry[type_class].previous();
            if (old == null)
                delete self.type_registry[type_class];
            self.type_registry[type_class] = old;
        }
        return self;
    }

    function multiple_resolvers_error(var type)
    {
        Rosella.Error.invalid(__FUNCTION__,
            "Multiple resolvers specified for type registration %",
            Rosella.get_type_name(type));
    }

    function alias(var type, string name)
    {
        self.aliases[name] = type;
    }

    function resolve(var type, var options [slurpy])
    {
        return self.resolve_internal(type, options);
    }

    function resolve_alias(string name, var options [slurpy])
    {
        if (exists self.aliases[name]) {
            var type = self.aliases[name];
            return self.resolve_internal(type, options);
        } else {
            Rosella.Error.invalid(__FUNCTION__, "Cannot resolve alias '%s'", name);
        }
    }

    function resolve_internal(var type, var options)
    {
        var type_class = Rosella.get_type_class(type);
        :(var resolver, var build_options, var misc_options) = self.sort_options(options);
        if (resolver == null) {
            if (exists self.type_registry[type_class])
                resolver = self.type_registry[type_class];
            else
                Rosella.Error.invalid(__FUNCTION__, "No Resolver specified for type %s",
                    type_class);
        }
        var instance = resolver.resolve(build_options, misc_options);
        return instance;
    }
}
