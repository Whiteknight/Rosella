function main[main](var args)
{
    load_bytecode("rosella/template.pbc");
    load_bytecode("rosella/filesystem.pbc");

    if (elements(args) != 4) {
        show_help();
        exit(0);
    }

    try {
        test_template_main(args[1], args[2], args[3]);
    } catch (e) {
        say(e["message"]);
        for (string bt in e.backtrace_strings())
            say(bt);
    }
}

function test_template_main(string testtype, string libname, string classname)
{
    load_bytecode(libname);
    using Rosella.get_type_class;
    using Rosella.String.replace_all;

    var targetclass = get_type_class(split(".", classname));
    var methods = targetclass.methods();

    string template = get_template(testtype);
    var context = {
        "class" : {
            "name" : classname,
            "cleanname" : replace_all(classname, ".", "_"),
            "winxedname" : classname,
            "perlname" : replace_all(classname, ".", "::"),
            "methods" : methods
        }
    };
    var engine = new Rosella.Template.Engine();
    string output = engine.generate(template, context);
    say(output);
}

const string TEMPLATE_FILE_FMT = "src/unstable/template/templates/test.%s.template";

function get_template(string testtype)
{
    string filename = sprintf(TEMPLATE_FILE_FMT, [testtype]);
    var file = new Rosella.FileSystem.File(filename);
    if (!file.exists()) {
        say("Cannot find template file for '" + testtype + "'");
        show_help();
        exit(0);
    }
    return file.read_all_text();
}

function show_help()
{
    string text = <<:
winxed test_template.winxed [winxed|nqp] <.pbc_file> <class_name>
Creates a stub test file from a library/classname combination, following a
preexisting template.
:>>
;
    say(text);
}
