namespace Rosella { namespace String
{
    class Tokenizer
    {
        var tokens;
        var data;
        var map;

        function Tokenizer()
        {
            self.tokens = [];
            self.data = null;
            self.map = {};
        }

        function add_data(string str)
        {
            if (self.data == null)
                self.data = str;
            else {
                string data = self.data;
                self.data = data + str;
            }
        }

        function set_data(string str)
        {
            self.data = str;
        }

        function get_all_data()
        {
            string d = self.data;
            self.data = null;
            return d;
        }

        function map_token(string key, var metadata)
        {
            self.map[key] = self.build_token(key, metadata);
        }

        function has_tokens()
        {
            if (elements(self.tokens) > 0)
                return 1;
            if (self.data != null && length(self.data) > 0)
                return 1;
            return 0;
        }

        function next_token()
        {
            if (elements(self.tokens) >= 1) {
                var token;
                var tokens = self.tokens;
                ${ shift token, tokens };
                return token;
            }
            if (self.data != null && self.data != "")
                return self.lex_next_token();
            return null;
        }

        function all_tokens()
        {
            var tokens = [];
            while (self.has_tokens()) {
                var t = self.next_token();
                push(tokens, t);
            }
            return tokens;
        }

        function get_token(string text, var metadata)
        {
            if (exists self.map[text])
                return self.map[text];
            return self.build_token(text, metadata);
        }

        function build_token(string text, var metadata)
        {
            return new Rosella.String.Tokenizer.Token(text, metadata);
        }

        function lex_next_token()
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella.String.Tokenizer");
        }

        function unget_token(var token)
        {
            // Do we want this to go onto the front or the back of the list?
            push(self.tokens, token);
        }

        function __get_chars(int count,
                int skip [optional], int has_skip [opt_flag])
        {
            string str = self.data;
            int len = length(str);
            if (count >= len) {
                self.data = null;
                return str;
            }
            if (!has_skip)
                skip = 0;
            self.data = substr(str, count + skip);
            return substr(str, 0, count);
        }
    }
}}
