namespace Rosella { namespace String
{
    class Tokenizer
    {
        var tokens;
        var data;
        var map;

        function Tokenizer()
        {
            self.tokens = [];
            self.data = null;
            self.map = {};
        }

        function add_data(string str)
        {
            if (self.data == null)
                self.data = str;
            else {
                string data = self.data;
                self.data = data + str;
            }
        }

        function map_token(string key, var metadata)
        {
            self.map[key] = self.build_token(key, metadata);
        }

        function has_tokens()
        {
            if (elements(self.tokens) > 0)
                return 1;
            if (self.data != null && length(self.data) > 0)
                return 1;
            return 0;
        }

        function next_token()
        {
            if (elements(self.tokens) > 1) {
                string token;
                var tokens = self.tokens;
                ${ shift token, tokens };
                return token;
            }
            if (self.data != null && self.data != "")
                return self.lex_next_token();
            return null;
        }

        function get_token(string text, var metadata)
        {
            if (exists self.map[text])
                return self.map[text];
            return self.build_token(text, metadata);
        }

        function build_token(string text, var metadata)
        {
            return new Rosella.String.Tokenizer.Token(text, metadata);
        }

        function lex_next_token()
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella.String.Tokenizer");
        }

        function unget_token(string token)
        {
            // Do we want this to go onto the front or the back of the list?
            push(self.tokens, token);
        }
    }
}}
