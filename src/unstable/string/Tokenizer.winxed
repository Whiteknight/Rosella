namespace Rosella { namespace String
{
    class Tokenizer
    {
        var tokens;
        var data;

        function Tokenizer()
        {
            self.tokens = [];
            self.data = null;
        }

        function add_data(string str)
        {
            if (self.data == null)
                self.data = str;
            else {
                string data = self.data;
                self.data = data + str;
            }
        }

        function has_tokens()
        {
            if (elements(self.tokens) > 0)
                return 1;
            if (self.data != null && length(self.data) > 0)
                return 1;
            return 0;
        }

        function get_token()
        {
            if (elements(self.tokens) > 1) {
                string token;
                var tokens = self.tokens;
                ${ shift token, tokens };
                return token;
            }
            if (self.data != null && self.data != "") {
                int type;
                int data;
                :(data, type) = self.lex_next_token();
                say(sprintf("Tokenizer data: %s, cclass: %d", [data, type]));
                return new Rosella.String.Tokenizer.Token(data, type);
            }
            return null;
        }

        function lex_next_token()
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella.String.Tokenizer");
        }

        function unget_token(string token)
        {
            // Do we want this to go onto the front or the back of the list?
            push(self.tokens, token);
        }

        function lex_next_token()
        {
            using Rosella.Error.must_subclass;
            must_subclass("String.Tokenizer.lex_next_token");
        }
    }
}}
