class Rosella.Net.Protocol.Http : Rosella.Net.Protocol
{
    function Http() { }

    function protocol_name() { return "http"; }

    function prepare_request(var request, var user_agent)
    {
        var header = request.header();
        var uri = request.get_uri();
        var proxy = request.get_proxy();

        string host = uri.authority();
        string userinfo;
        int amp_idx = index(host, "@");
        if (amp_idx >= 0) {
            userinfo = substr(host, 0, amp_idx);
            amp_idx++;
            host = substr(host, amp_idx);
            string auth = header.get_value("Authorization");
            if (auth == "") {
                string mimed = Rosella.Net.MimeBase64.encode(auth);
                header.add_value("Authorization", "Basic " + mimed);
            }
        }
        header.add_value("Host", host);
        if (proxy != null) {
            string userinfo = proxy.userinfo();
            if (userinfo != "") {
                string mimed = Rosella.Net.MimeBase64.encode(userinfo);
                header.add_value("Proxy-Authorization", "Basic " + mimed);
            }
        }
        if (!header.contains_value("Connection"))
            header.add_value("Connection", "Keep-Alive");
        if (!header.contains_value("User-Agent")) {
            string ua_string = user_agent.get_version_string();
            if (ua_string != null && ua_string != "")
                header.add_value("User-Agent", ua_string);
        }
    }

    function request(var request, var user_agent)
    {
        :(string host, int port, string fullpath) = self.__get_host_information(request, user_agent);
        var socket = Rosella.Net.tcp_socket_factory().create(host, port);

        if (!self.__send_request(socket, request, fullpath, user_agent))
            return self.__error_network_failure(request);
        user_agent.request_sent();

        :(int ok, var response) = self.__receive_status_line(socket);
        if (ok != 1)
            return response;
        user_agent.request_progress(PERCENT_REQUEST_SENT);

        self.__receive_header(socket, response.header());
        user_agent.request_progress(PERCENT_HEADERS_RECEIVED);

        if (!self.__receive_response_content(socket, response, user_agent))
            return self.__error_receive_failure(request, response);
        user_agent.request_complete();

        socket.close();
        return response;
    }

    function __format_request_header(string request_method, string fullpath, var request_header)
    {
        var sb = new 'StringBuilder';
        push(sb, request_method);
        push(sb, " ");
        push(sb, fullpath);
        push(sb, " HTTP/1.1");
        push(sb, CRLF);
        push(sb, request_header.get_header_text());
        push(sb, CRLF);
        return sb;
    }

    function __receive_status_line(var socket)
    {
        string status_line = socket.readline();
        status_line = Rosella.String.trim_end(status_line);
        int idx = index(status_line, " ");

        if (idx < 0)
            return false, new Rosella.Net.Http.Response(0, status_line);

        string protocol = substr(status_line, 0, idx);
        int next_idx = idx + 1;
        idx = index_issi(status_line, " ", next_idx);
        if (idx < 0)
            return false, new Rosella.Net.Http.Response(0, status_line, protocol);

        int diff = idx - next_idx;
        string code = substr(status_line, next_idx, diff);
        return true, new Rosella.Net.Http.Response(int(code), status_line, protocol);
    }

    function __receive_header(var socket, var header)
    {
        while (true) {
            string raw = socket.readline();
            raw = Rosella.String.trim_end(raw);
            if (raw == null || raw == "")
                return;
            int idx = index(raw, ": ");
            if (idx >= 0) {
                string name = substr(raw, 0, idx);
                string value = substr(raw, idx + 2);
                header.add_value(name, value);
            }
        }
    }

    function __get_host_information(var request, var user_agent)
    {
        var proxy = request.get_proxy();
        string request_method = request.get_method();
        var uri = request.get_uri();
        string host, port, fullpath;
        if (proxy != null) {
            host = proxy.host();
            port = proxy.port();
            fullpath = string(uri.host()) + ":" + string(uri.port());
        } else {
            host = uri.host();
            port = uri.port();
            fullpath = uri.path_query();
            if (index(fullpath, "/") != 0)
                fullpath = "/" + fullpath;
        }
        int port_num = (port == null || port == "") ? 80 : int(port);
        return host, port_num, fullpath;
    }

    function __send_request(var socket, var request, string fullpath, var user_agent)
    {
        string content = request.get_content();
        string header_raw = self.__format_request_header(request.get_method(), fullpath, request.header());
        if (socket.puts(header_raw) < 0)
            return false;
        if (content != null && content != "") {
            if (socket.puts(content) < 0)
                return false;
        }
        return true;
    }

    function __receive_response_content(var socket, var response, var user_agent)
    {
        var buf = new 'StringBuilder';
        string transfer_encoding = response.get_header("Transfer-Encoding");
        string raw;
        if (contains(transfer_encoding, "chunked")) {
            int hex_class = Rosella.String.get_character_class("hexadecimal");
            while(true) {
                // TODO: user_agent.request_progress()
                say("CHUNKED");
                string line = socket.readline();
                int line_length = length(line);
                int substr_idx = Rosella.String.first_not_cclass(line, hex_class);
                line = substr(line, 0, substr_idx);
                int chunk_length = Rosella.String.to_integer(line, 16);
                if (chunk_length == 0)
                    break;
                raw = socket.read(chunk_length);
                push(buf, raw);
                socket.readline();
            }
            self.__receive_header(socket, response.header());
        } else {
            int content_length = response.get_content_length_header();
            int recv_length = 0;
            if (content_length == 0) {
                while(true) {
                    raw = socket.recv();
                    if (raw == null || raw == "")
                        break;
                    recv_length += length(raw);
                    user_agent.request_progress(__status_percent(content_length, recv_length));
                    push(buf, raw);
                }
            } else {
                while (recv_length < content_length) {
                    string raw = socket.recv();
                    if (raw == "")
                        break;
                    recv_length += length(raw);
                    user_agent.request_progress(__status_percent(content_length, recv_length));
                    push(buf, raw);
                }
            }
        }
        response.set_content(string(buf));
        return true;
    }
}
