/* Utilities for working with Uri Objects
*/
namespace Rosella.Net.Uri
{
    const string URI_COMP_UNCHANGE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~";
    const string URI_UNCHANGE      = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~!*\'();:@&=+$,/?#[]";

    // Percent encode the input except for a list of characters that do not
    // require encoding
    function percent_encode_except(string s, string except)
    {
        int s_enc = get_string_encoding(s);
        int utf8_enc = get_encoding_id("utf8");
        if (s_enc != get_encoding_id("ascii") && s_enc != utf8_enc)
            s = reencode_string(s, utf8_enc);

        var buf = new 'ByteBuffer';
        var result = new 'ByteBuffer';
        buf =: s;
        for (int code in buf) {
            string c = codepoint_to_string(code);
            int idx = index_of_substr(except, c);
            if (idx == -1) {
                push(result, 0x25);
                c = substr(HEXDIGITS, code / 16, 1);
                push(result, get_codepoint(c, 0));
                c = substr(HEXDIGITS, code % 16, 1);
                push(result, get_codepoint(c, 0));
            } else {
                push(result, code);
                continue;
            }
        }
        s = result.get_string("ascii");
        return s;
    }

    // Normal percent-encoding rules, excepting most safe characters
    function percent_encode(string s) { return percent_encode_except(s, URI_UNCHANGE); }

    // Restrictive percent-encoding rules, only excepting alphanumerics and a few symbols
    function percent_encode_component(string s) { return percent_encode_except(s, URI_COMP_UNCHANGE); }
}

/* Uri
    This type is used to represent a Uri. A Uri should point uniquely to a
    resource object. The Uri contains information about the protocol to use and
    the path for the request to take.
*/
class Rosella.Net.Uri
{
    var parts;

    // Constructor
    function Uri(string uri)
    {
        self.parts = self.__parse(uri);
    }

    // Get the host
    function host() { return self.authority(); }

    // Get the raw Uri string
    function uri() { return self.parts["URI"]; }

    // TODO: ToLower
    // Get the protocol to use
    function protocol() { return self.parts["Protocol"]; }

    // Get the path
    function path() { return self.parts["Path"]; }

    // Get the authority
    function authority() { return self.parts["Authority"]; }

    // Get the port number
    function port() { return self.parts["Port"]; }

    // Get the Path and Query
    function path_query()
    {
        string path = self.parts["Path"];
        string query = self.parts["Query"];
        string fragment = self.parts["Fragment"];
        if (query != null && query != "")
            path = path + "?" + query;
        if (fragment != null && fragment != "")
            path = path + "#" + fragment;
        return path;
    }

    // Get the Query String
    function query() { return self.parts["Query"]; }

    // Get the fragment/anchor
    function fragment() { return self.parts["Fragment"]; }

    /* Private Helper Methods
    */

    // Get a hash containing default values
    function __default_parts_hash(string uri)
    {
        return {
            "URI" : uri,
            "Protocol": "",
            "Authority": "",
            "Path": "",
            "Port": "",
            "Query": "",
            "Fragment": ""
        };
    }

    // Parse the raw string uri and add it to the hash
    function __parse(string uri)
    {
        var hash_parts = self.__default_parts_hash(uri);
        int idx = index_of_substr(uri, "//");
        int s[] = [];
        var b = get_iterator(uri);
        int len = length(uri);
        string protocol = Rosella.Parse.parse_alphanumeric(uri, s, b, len);
        hash_parts["Protocol"] = protocol;
        switch(protocol) {
            case "http":
            case "https":
                self.__parse_http(uri, s, b, len, hash_parts);
                break;
            case "file":
                self.__parse_file(uri, s, b, len, hash_parts);
                break;
            default:
                Rosella.Error.error("Do not know how to parse Uri for protocol '%s'", protocol);
        }
        return hash_parts;
    }

    function __parse_http(string uri, var s, var b, int len, var hash_parts)
    {
        if (get_next(s, b) != ASCII_COLON ||
            get_next(s, b) != ASCII_SLASH ||
            get_next(s, b) != ASCII_SLASH)
            Rosella.Error.error("Http urls should begin with 'http://' or 'https://'");

        // Read out the authority information this is everything between the protocol and
        // the first forward slash (or end of string)
        :(string authority, int marker) = Rosella.Parse.parse_until_either(uri, s, b, len, ASCII_SLASH, ASCII_COLON);
        if (marker == ASCII_NULL) {
            hash_parts["Authority"] = authority;
            return;
        }

        // Search for a colon. If we find one we have one of these two formats:
        // <username>:<password>@<host>[:<port>]
        // <host>:<port>
        // We can determine which by searching next for an @ or a / (or end of string)
        if (marker == ASCII_COLON) {
            string save = authority;
            :(string tmp, marker) = Rosella.Parse.parse_until_either(uri, s, b, len, ASCII_AT_SIGN, ASCII_SLASH);

            // It's end of string. That means we have <protocol>://<host>:<port>
            if (marker == ASCII_NULL) {
                string port = tmp;
                hash_parts["Port"] = tmp;
                return;
            }

            // It's <protocol>://<username>:<password>@<host>[:<port>]
            if (marker == ASCII_AT_SIGN) {
                string username = save;
                string password = tmp;
                hash_parts["Username"] = username;
                hash_parts["Password"] = password;
                :(authority, marker) = Rosella.Parse.parse_until_either(uri, s, b, len, ASCII_COLON, ASCII_SLASH);
                hash_parts["Authority"] = authority;
                if (marker == ASCII_NULL)
                    return;
                if (marker == ASCII_COLON) {
                    :(string port, marker) = Rosella.Parse.parse_until(uri, s, b, len, ASCII_SLASH);
                    hash_parts["Port"] = port;
                    if (marker == ASCII_NULL)
                        return;
                }
            }
            else if (marker == ASCII_SLASH) {
                string port = tmp;
                hash_parts["Authority"] = authority;
                hash_parts["Port"] = port;
            }
        }
        // No colon, That means we have a simple <protocol>://<host> uri
        else
            hash_parts["Authority"] = authority;

        if (!have_more_chars(s, b))
            return;

        // Everything after the authority, but before a ? or a # is the path.
        // Get that, then figure out what to do next.
        :(string path, marker) = Rosella.Parse.parse_until_either(uri, s, b, len, ASCII_QUESTION_MARK, ASCII_OCTOTHORPE);
        hash_parts["Path"] = path;
        if (marker == ASCII_NULL)
            return;

        // If ?, we have a query string. Get that, looking for a fragment or EOS
        string query = "";
        if (marker == ASCII_QUESTION_MARK) {
            :(query, marker) = Rosella.Parse.parse_until(uri, s, b, len, ASCII_OCTOTHORPE);
            hash_parts["Query"] = query;
            if (marker == ASCII_NULL)
                return;
        }

        // If # we have a fragment. This is the last bit of the uri
        string fragment = "";
        if (marker == ASCII_OCTOTHORPE) {
            fragment = Rosella.Parse.parse_remainder(uri, s, b, len);
            hash_parts["Fragment"] = fragment;
        }
    }

    function __parse_file(string uri, var s, var b, int len, var hash_parts)
    {
        if (get_next(s, b) != ASCII_COLON ||
            get_next(s, b) != ASCII_SLASH ||
            get_next(s, b) != ASCII_SLASH)
            Rosella.Error.error("File urls should begin with 'file://'");

        // Read out the authority information this is everything between the protocol and
        // the first forward slash (or end of string)
        :(string host, int marker) = Rosella.Parse.parse_until(uri, s, b, len, ASCII_SLASH);
        if (marker == ASCII_NULL)
            Rosella.Error.error("Empty file:// uri");
        if (host == null || host == "")
            host = ".";
        hash_parts["Authority"] = host;

        string path = Rosella.Parse.parse_remainder(uri, s, b, len);
        hash_parts["Path"] = path;
    }
}
