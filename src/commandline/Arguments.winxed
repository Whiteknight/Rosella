/* Argument Parser and Value Accessor
    This class takes a series of argument specifications, and parses the
    argument list to extract the necessary values.
*/
class Rosella.CommandLine.Arguments
{
    var program;        // The Program object
    var remainder;      // The list of all arguments after -- which are not parsed
    var named_cache;    // The cache of already-parsed args
    var pos_cache;      // All positional arguments
    var raw_defs;       // Cache of raw argument definitions
    var raw_args;       // The raw argument list
    var arg_defs;       // Processed arg definitions

    // Constructor. Take the list of arguments and do a fast presort on them.
    function Arguments(var program)
    {
        self.program = program;
    }

    // Get the program name
    function program_name()
    {
        return self.program.program_name;
    }

    function prepare_arg_defs(var defs)
    {
        var arg_defs = Rosella.get_string_string_hash();
        self.raw_defs = defs;
        if (does(defs, "hash"))
            self.__prepare_arg_defs_hash(defs, arg_defs);
        else if (does(defs, "array"))
            self.__prepare_arg_defs_array(defs, arg_defs);
        else
            Rosella.Error.error("Unknown argument definition type '%s'", typeof(defs));
        self.arg_defs = arg_defs;
        return arg_defs;
    }

    /* We can handle defs of the following types:
        foo         f
        foo=s       f=s
        foo=[]      f=[]
        foo={}      f={}
    */
    function __prepare_arg_defs_hash(var defs, var arg_defs)
    {
        for (string arg_def in defs) {
            var parts = split("=", arg_def);

            // Get the name of the argument
            string raw_arg_name = parts[0];
            string arg_name;
            if (length(raw_arg_name) == 1)
                arg_name = "-" + raw_arg_name;
            else
                arg_name = "--" + raw_arg_name;

            // Now get a flag that tells us how to work with it.
            string flag = "f";
            if (elements(parts) == 2) {
                string second_part = parts[1];
                switch(second_part) {
                    case "s":
                    case "[]":
                    case "{}":
                        flag = parts[1];
                        break;
                    default:
                        Rosella.Error.error("Unknown argument type for '%s': '%s'", raw_arg_name, second_part);
                }
            }

            arg_defs[arg_name] = flag;
        }
    }

    // TODO: If we get an array of arrays, try to copy old-style
    // GetOpt::Obj format
    function __prepare_arg_defs_array(var defs, var arg_defs)
    {

    }

    function __get_def(string name, var defs)
    {
        if (exists defs[name])
            return defs[name];
        Rosella.Error.error("Unknown argument '%s'", name);
    }

    function __get_next(var args, int i, var lookahead)
    {
        int single = true;
        string arg;
        if (elements(lookahead) > 0)
            arg = lookahead.shift();
        else {
            arg = args[i];
            i++;
        }

        int idx = indexof(arg, ":");
        if (idx != -1) {
            var parts = split(":", arg);
            arg = parts[0];
            unshift(lookahead, parts[1]);
            single = false;
        }
        return arg, i, single;
    }

    function __has_more(var args, int i, var lookahead)
    {
        return elements(lookahead) > 0 || i < elements(args);
    }

    function parse(var args, var raw_arg_defs)
    {
        string lookahead[] = [];
        var arg_defs = self.prepare_arg_defs(raw_arg_defs);
        var named_cache = {};
        string remainders[];
        string positionals[] = [];

        int i = 0;
        while (self.__has_more(args, i, lookahead)) {
            :(string arg, i, int single) = self.__get_next(args, i, lookahead);

            // All arguments after "--" are not parsed. Add them all to the
            // remainders list
            if (arg == "--") {
                remainders = [];
                for (i++; i < elements(args); i++)
                    push(remainders, args[i]);
                break;
            }

            string arg_name = "";

            // An arg of the form "--foo", "--foo bar", "--foo:bar",
            // "--foo bar=baz", "--foo:bar=baz"
            if (substr(arg, 0, 2) == "--")
                arg_name = arg;

            // An arg of the form "-X", "-Xfoo", "-X foo", "-f:bar", "-Xfoo=bar",
            // "-X foo=bar", "-X:foo=bar"
            else if (substr(arg, 0, 1) == "-") {
                if (length(arg) > 2) {
                    arg_name = substr(arg, 0, 2);
                    string extra = substr(arg, 2);
                    unshift(lookahead, extra);
                } else if (length(arg) == 2)
                    arg_name = arg;
                else
                    Rosella.Error.error("Unknown argument format '%s'", arg);
            }


            // A positional arg
            else {
                push(positionals, arg);
                continue;
            }

            string def = self.__get_def(arg_name, arg_defs);
            switch(def) {
                case "f":
                    if (single == false)
                        Rosella.Error.error("Unexpected scalar value for flag '%s'", arg_name);
                    named_cache[arg_name] = true;
                    break;
                case "s":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unknown syntax for argument '%s'", arg_name);
                    named_cache[arg_name] = var(arg);
                    break;
                case "[]":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unexpected pair value for list '%s'", arg_name);
                    if (!(exists named_cache[arg_name]))
                        named_cache[arg_name] = new 'ResizableStringArray';
                    push(named_cache[arg_name], arg);
                    break;
                case "{}":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unexpected pair value for list '%s'", arg_name);
                    if (!(exists named_cache[arg_name]))
                        named_cache[arg_name] = Rosella.get_string_string_hash();
                    var h = named_cache[arg_name];
                    var parts = split("=", arg);
                    if (elements(parts) != 2)
                        Rosella.Error.error("Unexpected syntax for pair '%s': '%s'", arg_name, arg);
                    h[string(parts[0])] = parts[1];
                    break;
            }
        }

        // Loop over the arg_defs, adding false values for any missing flags
        for (string arg_name in arg_defs) {
            string arg_flag = arg_defs[arg_name];
            if (arg_flag == "f") {
                if (!(exists named_cache[arg_name]))
                    named_cache[arg_name] = false;
            }
        }

        // Finally, store values into object fields
        self.named_cache = named_cache;
        self.pos_cache = positionals;
        self.remainder = remainders;
        self.raw_args = args;
    }

    function get_description()
    {
        int max = 0;
        for (string arg in self.raw_defs) {
            int len = length(arg);
            if (len > max)
                max = len;
        }
        max += 4;
        var sb = new 'StringBuilder';
        for (string arg in self.raw_defs) {
            string desc = self.raw_defs[arg];
            push(sb, "    ");
            push(sb, arg);
            push(sb, repeat_string(" ", max - length(arg)));
            push(sb, desc);
            push(sb, "\n");
        }
        return sb;
    }

    // Get the remaining args
    function remainder()
    {
        return self.remainder;
    }

    // Get the raw list of args. Notice that this list is destroyed during
    // parsing
    function raw_args()
    {
        return self.raw_args;
    }

    function get_integer_keyed[vtable](string name)
    {
        if (exists self.pos_cache[name])
            return self.pos_cache[name];
        return false;
    }

    // Once parsed, provide keyed access to the cache
    function get_string_keyed[vtable](string name)
    {
        if (exists self.named_cache[name])
            // TODO: Check if it's a string. Lists and hashes shouldn't be
            //       accessed like this
            return self.cache[name];
        return "";
    }

    // Once parsed, provide keyed access to the cache
    function get_pmc_keyed[vtable](string name)
    {
        if (exists self.named_cache[name])
            return self.named_cache[name];
        return null;
    }

    function get_string_keyed_int[vtable](int idx)
    {
        if (elements(self.pos_cache) > idx)
            return self.pos_cache[idx];
        return "";
    }
}
