/* Argument Parser and Value Accessor
    This class takes a series of argument specifications, and parses the
    argument list to extract the necessary values.
*/
class Rosella.CommandLine.Arguments
{
    var program;        // The Program object
    var remainder;      // The list of all arguments after -- which are not parsed
    var named_cache;    // The cache of already-parsed args
    var pos_cache;      // All positional arguments
    var raw_args;       // The raw argument list
    var arg_defs;       // Processed arg definitions

    // Constructor. Take the list of arguments and do a fast presort on them.
    function Arguments(var program)
    {
        self.program = program;
    }

    /* Public API Functions
    */

    // Get the program name
    function program()
    {
        return self.program;
    }

    function parse(var args, var arg_defs_obj)
    {
        var arg_defs = arg_defs_obj.get_definitions();
        string lookahead[] = [];
        var named_cache = {};
        string remainders[];
        string positionals[] = [];

        int i = 0;
        while (self.__has_more(args, i, lookahead)) {
            :(string arg, i, int single) = self.__get_next(args, i, lookahead);

            // All arguments after "--" are not parsed. Add them all to the
            // remainders list
            if (arg == "--") {
                remainders = [];
                for (; i < elements(args); i++)
                    push(remainders, args[i]);
                break;
            }

            string arg_name = "";

            // An arg of the form "--foo", "--foo bar", "--foo:bar",
            // "--foo bar=baz", "--foo:bar=baz"
            if (substr(arg, 0, 2) == "--")
                arg_name = arg;

            // An arg of the form "-X", "-Xfoo", "-X foo", "-f:bar", "-Xfoo=bar",
            // "-X foo=bar", "-X:foo=bar"
            else if (substr(arg, 0, 1) == "-") {
                if (length(arg) > 2) {
                    arg_name = substr(arg, 0, 2);
                    string extra = substr(arg, 2);
                    unshift(lookahead, extra);
                } else if (length(arg) == 2)
                    arg_name = arg;
                else
                    Rosella.Error.error("Unknown argument format '%s'", arg);
            }


            // A positional arg
            else {
                push(positionals, arg);
                continue;
            }

            string def = self.__get_def(arg_name, arg_defs);
            switch(def) {
                case "f":
                    if (single == false)
                        Rosella.Error.error("Unexpected scalar value for flag '%s'", arg_name);
                    named_cache[arg_name] = true;
                    break;
                case "s":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unknown syntax for argument '%s'", arg_name);
                    named_cache[arg_name] = var(arg);
                    break;
                case "[]":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unexpected pair value for list '%s'", arg_name);
                    if (!(exists named_cache[arg_name]))
                        named_cache[arg_name] = new 'ResizableStringArray';
                    push(named_cache[arg_name], arg);
                    break;
                case "{}":
                    :(arg, i, single) = self.__get_next(args, i, lookahead);
                    if (single == false)
                        Rosella.Error.error("Unexpected pair value for list '%s'", arg_name);
                    if (!(exists named_cache[arg_name]))
                        named_cache[arg_name] = Rosella.get_string_string_hash();
                    var h = named_cache[arg_name];
                    var parts = split("=", arg);
                    if (elements(parts) != 2)
                        Rosella.Error.error("Unexpected syntax for pair '%s': '%s'", arg_name, arg);
                    string val_name = parts[0];
                    string value = parts[1];
                    h[val_name] = value;
                    break;
            }
        }

        // Loop over the arg_defs, adding false values for any missing flags
        for (string arg_name in arg_defs) {
            string arg_flag = arg_defs[arg_name];
            if (arg_flag == "f") {
                if (!(exists named_cache[arg_name]))
                    named_cache[arg_name] = false;
            }
        }

        // Finally, store values into object fields
        self.named_cache = named_cache;
        self.pos_cache = positionals;
        self.remainder = remainders;
        self.raw_args = args;
        self.arg_defs = arg_defs_obj;
    }

    function get_argument_definitions()
    {
        return self.arg_defs;
    }

    // Get the remaining args
    function remainder()
    {
        return self.remainder;
    }

    // Get the raw list of args. Notice that this list is destroyed during
    // parsing
    function raw_args()
    {
        return self.raw_args;
    }

    /* VTABLEs
    */

    function get_integer_keyed[vtable](string name)
    {
        if (exists self.named_cache[name])
            return self.named_cache[name];
        return false;
    }

    // Once parsed, provide keyed access to the cache
    function get_string_keyed[vtable](string name)
    {
        if (exists self.named_cache[name])
            // TODO: Check if it's a string. Lists and hashes shouldn't be
            //       accessed like this
            return self.named_cache[name];
        return "";
    }

    // Once parsed, provide keyed access to the cache
    function get_pmc_keyed[vtable](string name)
    {
        if (exists self.named_cache[name])
            return self.named_cache[name];
        return null;
    }

    function get_string_keyed_int[vtable](int idx)
    {
        if (elements(self.pos_cache) > idx)
            return self.pos_cache[idx];
        return "";
    }

    function get_pmc_keyed_int[vtable](int idx)
    {
        if (elements(self.pos_cache) > idx)
            return self.pos_cache[idx];
        return "";
    }

    /* Private Helper Methods
    */

    function __get_def(string name, var defs)
    {
        if (exists defs[name])
            return defs[name];
        Rosella.Error.error("Unknown argument '%s'", name);
    }

    function __get_next(var args, int i, var lookahead)
    {
        int single = true;
        string arg;
        if (elements(lookahead) > 0)
            arg = lookahead.shift();
        else {
            arg = args[i];
            i++;
        }

        int idx = indexof(arg, ":");
        if (idx != -1) {
            var parts = split(":", arg);
            arg = parts[0];
            unshift(lookahead, parts[1]);
            single = false;
        }
        return arg, i, single;
    }

    function __has_more(var args, int i, var lookahead)
    {
        return elements(lookahead) > 0 || i < elements(args);
    }
}
