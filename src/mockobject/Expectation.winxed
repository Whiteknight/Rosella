namespace Rosella { namespace MockObject
{
    class Expectation
    {
        var quantity;          // The number of times we expect this behavior
        var quantity_modifier; // "=", "<=", ">="
        var type;              // "method", "get_attribute", "set_attribute", "invoke"
        var name;              // The name of the method/attribute
        var will;              // What the mock will do, once matched
        var with;              // What values the mock is expecting to match

        function BUILD()
        {
            self.quantity = 1;
            self.quantity_modifier = "=";
            self.type = null;
            self.name = null;
            self.will = null;
            self.with = null;
        }

        function to_string() {
            return sprintf("Expected %s '%s' (n %s %d times)",
                [self.type, self.name, self.quantity_modifier, self.quantity]
            );
        }

        /* Quantifiers
            Tell how many times we expect this to happen
        */

        function quantity(int num, string mod)
        {
            self.quantity = num;
            self.quantity_modifier = mod;
            return self;
        }
        function once() { return self.quantity(1, "="); }
        function none() { return self.quantity(0, "="); } // This is really a no-op
        function exactly(int n) { return self.quantity(n, "="); }
        function any() { return self.quantity(0, ">="); }
        function at_least(int n) { return self.quantity(n, ">="); }
        function at_most(int n) { return self.quantity(n, "<="); }

        /* Expectation Type
            The type of behavior we expect.
        */

        function method(string name)
        {
            self.name = name;
            self.type = "method";
            return self;
        }

        function get(string name)
        {
            self.name = name;
            self.type = "get_attribute";
            return self;
        }

        function set(string name)
        {
            self.name = name;
            self.type = "set_attribute";
            return self;
        }

        function invoke()
        {
            self.type = "invoke";
            self.name = null;
            return self;
        }

        /* Behaviors
            These are things the mock should do in response to the request.
            Typically the options are to return a value or to throw an
            exception.

            Will behaviors can only be set once we know the type.
        */

        function will_return(var value)
        {
            using Rosella.build;

            self.__can_set_will();
            if (self.type == "set_attribute")
                die("set_attribute does not return a value");
            self.will = build(class Rosella.MockObject.Expectation.Will.Return, value);
            return self;
        }

        function will_throw(var value)
        {
            using Rosella.build;

            self.__can_set_will();
            self.will = build(class Rosella.MockObject.Expectation.Will.Throw, value);
            return self;
        }

        function will(var will)
        {
            self.__can_set_will();
            self.will = will;
            return self;
        }

        function __can_set_will()
        {
            if (self.type == null)
                die("Type not set");
            if (self.will != null)
                die("Cannot set Will behavior twice");
        }

        /* Arguments
            methods, invokes, and set_attribute requests all take parameters.
            These methods set up the expectation to match those.
        */

        function with_args(var pos [slurpy], var named [named,slurpy])
        {
            using Rosella.build;

            self.__verify_can_set_args();
            if (self.type == "set_attribute") {
                if (int(pos) != 1 || int(named) != 0)
                    die("set_attribute takes exactly 1 positional and 0 named args");
            }
            self.with = build(class Rosella.MockObject.Expectation.With.Args, pos, named);
            return self;
        }

        function with_any_args()
        {
            using Rosella.build;

            self.__verify_can_set_args();
            self.with = build(class Rosella.MockObject.Expectation.With.Any);
            return self;
        }

        function with_no_args()
        {
            using Rosella.build;

            self.__verify_can_set_args();
            if (self.type == "set_attribute")
                die("set_attribute must have 1 argument");
            self.with = build(class Rosella.MockObject.Expectation.With.None);
            return self;
        }

        function with(var with)
        {
            self.__verify_can_set_args();
            self.with = with;
            return self;
        }

        // Basic sanity check that we can set arguments. Check that we are in
        // a mode that accepts arguments
        function __verify_can_set_args()
        {
            if (self.type == null)
                die("no behavior set");
            if (self.type == "get_attribute")
                die("attribute get does not take args");
            //if (self.with_behavior != null)
            //    die("You cannot specify arguments twice");
        }

        /* Internal Methods
            These methods are used internally by the mock system and should
            not be used by user code
        */

        // Match a given set of arguments against the expected list
        function __match_args(var pos, var named)
        {
            if (self.with == null)
                return 1;
            int is_match = self.with.match(pos, named);
            return is_match;
        }

        // True if this expectation can match the specified method call with
        // args
        function __can_match_function_args(string name, var pos, var named)
        {
            if (self.type != "method" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            if (!self.__match_args(pos, named))
                return 0;
            return 1;
        }

        // True if this expectation can match the specified get_attribute
        // request
        function __can_match_get_attr(string name)
        {
            if (self.type != "get_attribute" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            return 1;
        }

        // True if this expectation can match the specified set_attribute
        // request
        function __can_match_set_attr(string name, var value)
        {
            if (self.type != "set_attribute" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            if (!self.__match_args([value], {}))
                return 0;
            return 1;
        }

        // True if this expecation can match the specified invoke request
        function __can_match_invoke(var pos, var named)
        {
            if (self.type != "invoke")
                return 0;
            if (!self.__available())
                return 0;
            if (!self.__match_args(pos, named))
                return 0;
            return 1;
        }

        // mark this expectation matched, and reduce the quantity available.
        function __match()
        {
            self.quantity--;
        }

        // true if this expectation is available to be matched. This depends
        // on both the quantity and modifier
        function __available()
        {
            if (string(self.quantity_modifier) == "=" && self.quantity > 0)
                return 1;
            if (string(self.quantity_modifier) == "<=" && self.quantity > 0)
                return 1;
            if (string(self.quantity_modifier) == ">=")
                return 1;
            return 0;
        }

        // true if this expectation has been satisfied. We are satisfied if
        // our remaining quantity and our quantity modifier say we are
        // satisfied
        function __satisfied()
        {
            if (string(self.quantity_modifier) == "=" && self.quantity == 0)
                return 1;
            if (string(self.quantity_modifier) == "<=" && self.quantity >= 0)
                return 1;
            if (string(self.quantity_modifier) == ">=" && self.quantity <= 0)
                return 1;
            return 0;
        }

        // execute the will behavior, returning any necessary values or
        // throwing any necessary exceptions
        function __run_will_behavior()
        {
            if (self.will == null)
                return null;
            return self.will.execute();
        }
    }
}}
