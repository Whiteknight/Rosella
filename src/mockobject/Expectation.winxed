namespace Rosella { namespace MockObject
{
    class Expectation
    {
        var quantity;          // The number of times we expect this behavior
        var quantity_modifier; // "=", "<=", ">="
        var type;              // "method", "get_attribute", "set_attribute", "invoke"
        var name;              // The name of the method/attribute
        var pos_args;          // Positional arguments
        var named_args;        // Named arguments
        var with_behavior;     // "any", "verbatim", "none"
        var will_behavior;     // Whether to "return" or "throw"
        var will_value;        // The value to return or throw

        function BUILD()
        {
            self.quantity = 1;
            self.quantity_modifier = "=";
            self.type = null;
            self.name = null;
            self.pos_args = null;
            self.named_args = null;
            self.will_behavior = "return";
            self.will_value = null;
            self.with_behavior = "any";
        }

        function to_string() {
            say("expect.to_string");
            return sprintf("Expected %s '%s' (n %s %d times)", [self.type, self.name, self.quantity_modifier, self.quantity]);
        }

        /* Quantifiers
            Tell how many times we expect this to happen
        */

        function quantity(int num, string mod)
        {
            self.quantity = num;
            self.quantity_modifier = mod;
            return self;
        }
        function once() { return self.quantity(1, "="); }
        function none() { return self.quantity(0, "="); } // This is really a no-op
        function at_least(int n) { return self.quantity(n, ">="); }
        function at_most(int n) { return self.quantity(n, "<="); }

        /* Expectation Type
            The type of behavior we expect.
        */
        // TODO: Try to refactor some of this logic into delegate classes

        function method(string name)
        {
            self.name = name;
            self.type = "method";
            return self;
        }

        function get_attribute(string name)
        {
            self.name = name;
            self.type = "get_attribute";
            return self;
        }

        function set_attribute(string name)
        {
            self.name = name;
            self.type = "set_attribute";
            return self;
        }

        function invoke()
        {
            self.type = "invoke";
            self.name = null;
            return self;
        }

        /* Behaviors
            These are things the mock should do in response to the request.
            Typically the options are to return a value or to throw an
            exception.
        */

        function will_return(var value)
        {
            if (self.type == null)
                die("Type not set");
            if (self.type == "set_attribute")
                die("set_attribute does not return a value");
            self.will_behavior = "return";
            self.will_value = value;
            return self;
        }

        function will_throw(var value)
        {
            self.will_behavior = "throw";
            self.will_value = value;
            return self;
        }

        /* Arguments
            methods, invokes, and set_attribute requests all take parameters.
            These methods set up the expectation to match those.
        */

        function with_args(var pos [slurpy], var named [named,slurpy])
        {
            self.__verify_can_set_args();
            if (self.type == "set_attribute") {
                if (int(pos) != 1 || int(named) != 0)
                    die("set_attribute takes exactly 1 positional and 0 named args");
            }
            self.with_behavior = "verbatim";
            self.pos_args = pos;
            self.named_args = named;
            return self;
        }

        function with_any_args()
        {
            self.__verify_can_set_args();
            self.with_behavior = "any";
            return self;
        }

        function with_no_args()
        {
            self.__verify_can_set_args();
            if (self.type == "set_attribute")
                die("set_attribute must have 1 argument");
            self.with_behavior = "none";
            return self;
        }


        /* Internal Methods
            These methods are used internally by the mock system and should
            not be used by user code
        */

        // Basic sanity check that we can set arguments. Check that we are in
        // a mode that accepts arguments
        function __verify_can_set_args()
        {
            if (self.type == null)
                die("no behavior set");
            if (self.type == "get_attribute")
                die("attribute get does not take args");
            //if (self.with_behavior != null)
            //    die("You cannot specify arguments twice");
        }

        // Match a given set of arguments against the expected list
        function __match_args(var pos, var named)
        {
            // If any, we always match. If none, we match if we received
            // nothing.
            if (string(self.with_behavior) == "any")
                return 1;
            if (string(self.with_behavior) == "none") {
                if (int(pos) != 0 || int(named) != 0)
                    return 0;
                return 1;
            }

            // Check that we have the correct number of args.
            if (int(pos) != int(self.pos_args))
                return 0;
            if (int(named) != int(self.named_args))
                return 0;

            // Check that we have the correct values
            for (int i = 0; i < int(pos); i++) {
                if (pos[i] != self.pos_args[i])
                    return 0;
            }
            for (string name in named) {
                if (!(exists self.named_args[name]))
                    return 0;
                if (named[name] != self.named_args[named])
                    return 0;
            }
            return 1;
        }

        // True if this expectation can match the specified method call with
        // args
        function __can_match_function_args(string name, var pos, var named)
        {
            if (self.type != "method" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            if (!self.__match_args(pos, named))
                return 0;
            return 1;
        }

        // True if this expectation can match the specified get_attribute
        // request
        function __can_match_get_attr(string name)
        {
            if (self.type != "get_attribute" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            return 1;
        }

        // True if this expectation can match the specified set_attribute
        // request
        function __can_match_set_attr(string name, var value)
        {
            if (self.type != "set_attribute" || self.name != name)
                return 0;
            if (!self.__available())
                return 0;
            if (self.pos_args[0] != value)
                return 0;
            return 1;
        }

        // True if this expecation can match the specified invoke request
        function __can_match_invoke(var pos, var named)
        {
            if (self.type != "invoke")
                return 0;
            if (!self.__available())
                return 0;
            if (!self.__match_args(pos, named))
                return 0;
            return 1;
        }

        // mark this expectation matched, and reduce the quantity available.
        function __match()
        {
            self.quantity--;
        }

        // true if this expectation is available to be matched. This depends
        // on both the quantity and modifier
        function __available()
        {
            if (string(self.quantity_modifier) == "=" && self.quantity > 0)
                return 1;
            if (string(self.quantity_modifier) == "<=" && self.quantity > 0)
                return 1;
            if (string(self.quantity_modifier) == ">=")
                return 1;
            return 0;
        }

        // true if this expectation has been satisfied. We are satisfied if
        // our remaining quantity and our quantity modifier say we are
        // satisfied
        function __satisfied()
        {
            if (string(self.quantity_modifier) == "=" && self.quantity == 0)
                return 1;
            if (string(self.quantity_modifier) == "<=" && self.quantity >= 0)
                return 1;
            if (string(self.quantity_modifier) == ">=" && self.quantity <= 0)
                return 1;
            return 0;
        }

        // execute the will behavior, returning any necessary values or
        // throwing any necessary exceptions
        function __run_will_behavior()
        {
            if (self.will_behavior == null)
                return null;
            if (self.will_behavior == "return")
                return self.will_value;
            if (self.will_behavior == "throw")
                die(self.will_value);
            return null;
        }
    }
}}
