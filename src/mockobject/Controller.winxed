namespace Rosella { namespace MockObject
{
    /* Mock Object Controller
        configures expectations on the mock, and handles all the messy details
        of object proxying and expectation setup/verification.

        In a mockobject-based test, there are a few basic steps:

        1. Create a mock object factory
        2. Use the factory to create a controller
        3. Use the controller to setup expectations.
        4. Get the mock from the controller
        5. Run your test logic, executing requests against the mock
        6. Call controller.verify() to verify all expectations have been met.
    */
    class Controller : Rosella.Proxy.Controller
    {
        var mock;
        var expectations;

        function BUILD()
        {
            self.expectations = [];
        }

        /* Mocking Methods
            These methods are used to help setup and control the mock
        */

        // Create and return a new expectation object.
        function expect()
        {
            using Rosella.build;
            var expect = build(class Rosella.MockObject.Expectation);
            push(self.expectations, expect);
            return expect;
        }

        function mock()
        {
            return self.mock;
        }

        function verify()
        {
            using Assert.fail;
            var missed_expectations = [];
            for (var expect in self.expectations) {
                if (!expect.__satisfied())
                    push(missed_expectations, expect);
            }
            if (int(missed_expectations) == 0)
                return;
            string errmsg = "Not all expectations have been met!";
            for (var missed in missed_expectations)
                errmsg = errmsg + "\n\t" + string(missed.to_string());
            fail(errmsg);
        }

        /* Controller Methods
            These methods are used to satisfy the Rosella::Proxy::Controller
            interface. These are the routines used by the mock to intercept
            and validate behavior.
        */

        // intercept find_method vtable calls. Check if we have any
        // expectations available by this name. If we do, return a stub
        // method object to be used in place of the method call.
        function find_method(var proxy, string name)
        {
            using Assert.fail;
            int expects = self.have_method_expectations(name);
            if (expects == 0)
                self.unmatched("method '" + name + "'");
            var controller = self;
            var name_pmc = name; // needs to be a PMC to be lexically scoped
            return function(var pos [slurpy], var named [slurpy,named])
                    {
                        var dummy = null;
                        ${ shift dummy, pos }; // remove the invocant. We know it's the mock
                        return controller.match_function(name_pmc, pos, named);
                    };
        }

        // Callback when the mock receives a get_attr_str request
        function get_attr_str(var proxy, string name)
        {
            var expectations = self.available_expectations();
            for (var expect in expectations) {
                if (expect.__can_match_get_attr(name))
                    return self.complete_expectation(expect);
            }
            self.unmatched("get_attr '" + name + "'");
        }

        // Callback when the mock receives a set_attr_str request
        function set_attr_str(var proxy, string name, var value)
        {
            var expectations = self.available_expectations();
            for (var expect in expectations) {
                if (expect.__can_match_set_attr(name, value)) {
                    self.complete_expectation(expect);
                    return;
                }
            }
            self.unmatched("set_attr '" + name + "'");
        }

        // Callback for when the mock is invoked. Note that not all mocks
        // support invoke. You need to specify that behavior in the factory.
        function invoke(var proxy, var pos, var named)
        {
            var expectations = self.available_expectations();
            for (var expect in expectations) {
                if (expect.__can_match_invoke(pos, named))
                    return self.complete_expectation(expect);
            }
            self.unmatched("invoke");
        }

        /* Support Routines
            These routines are used internally to the Controller and should
            not be used by other code
        */

        // return 1 if we have an expectation available for the given method
        // name. 0 otherwise. This way we can identify the expectation failure
        // inside find_method instead of after we invoke the method.
        function have_method_expectations(string name)
        {
            int count = 0;
            for (var expect in self.expectations) {
                if (expect.type == "method" && expect.name == name && expect.__available())
                    return 1;
            }
            return 0;
        }

        // Fail the test because we could not match
        function unmatched(string type)
        {
            using Assert.fail;
            fail("Can not match " + type);
        }

        // Attempt to match a method invoke to an expectation.
        function match_function(string name, var pos, var named)
        {
            var expectations = self.available_expectations();
            for (var expect in expectations) {
                if (expect.__can_match_function_args(name, pos, named))
                    return self.complete_expectation(expect);
            }
            self.unmatched("method invoke '" + name + "'");
        }

        // We have a matching expectation. Do whatever we need to do to mark
        // it matched and execute any necessary behaviors
        function complete_expectation(var expect)
        {
            expect.__match();
            return expect.__run_will_behavior();
        }

        // Get a list of all available expectations
        function available_expectations()
        {
            return self.expectations;
        }
    }
}}
