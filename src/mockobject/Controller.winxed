namespace Rosella { namespace MockObject
{
    /* Mock Object Controller
        configures expectations on the mock, and handles all the messy details
        of object proxying and expectation setup/verification.

        In a mockobject-based test, there are a few basic steps:

        1. Create a mock object factory
        2. Use the factory to create a controller
        3. Use the controller to setup expectations.
        4. Get the mock from the controller
        5. Run your test logic, executing requests against the mock
        6. Call controller.verify() to verify all expectations have been met.
    */
    class Controller : Rosella.Proxy.Controller
    {
        var mock;
        var expectations;

        function BUILD()
        {
            self.expectations = [];
        }

        /* Mocking Methods
            These methods are used to help setup and control the mock
        */

        // Create and return a new expectation object.
        function expect()
        {
            using Rosella.build;
            var expect = build(class Rosella.MockObject.Expectation);
            push(self.expectations, expect);
            return expect;
        }

        function mock()
        {
            return self.mock;
        }

        function verify()
        {
            using Assert.fail;
            var missed_expectations = [];
            for (var expect in self.expectations) {
                if (!expect.__satisfied())
                    push(missed_expectations, expect);
            }
            if (int(missed_expectations) == 0)
                return;
            string errmsg = "Not all expectations have been met!";
            for (var missed in missed_expectations) {
                errmsg = errmsg + "\n\t" + string(missed.to_string());
            }
            fail(errmsg);
        }

        /* Controller Methods
            These methods are used to satisfy the Rosella::Proxy::Controller
            interface. These are the routines used by the mock to intercept
            and validate behavior.
        */

        // intercept find_method vtable calls. Check if we have any
        // expectations available by this name. If we do, return a stub
        // method object to be used in place of the method call.
        function find_method(var proxy, string name)
        {
            using Assert.fail;
            int expects = self.method_expectations(name);
            if (expects == 0)
                fail("Unexpected call to method " + name);
            var controller = self;
            var name_pmc = name; // needs to be a PMC to be lexically scoped
            return function(var pos [slurpy], var named [slurpy,named])
                    {
                        var dummy = null;
                        ${ shift dummy, pos }; // remove the invocant. We're not a method call here
                        var expect = controller.match_function(name_pmc, pos, named);
                        return expect.__run_will_behavior();
                    };
        }

        // Callback when the mock receives a get_attr_str request
        function get_attr_str(var proxy, string name)
        {
            for (var expect in self.expectations) {
                if (expect.__can_match_get_attr(name)) {
                    expect.__match();
                    return expect.__run_will_behavior();
                }
            }
            using Assert.fail;
            fail("Can not match get " + name);
        }

        // Callback when the mock receives a set_attr_str request
        function set_attr_str(var proxy, string name, var value)
        {
            for (var expect in self.expectations) {
                if (expect.__can_match_set_attr(name, value)) {
                    expect.__match();
                    expect.__run_will_behavior(); // everything besides "throw" is ignored
                    return;
                }
            }
            using Assert.fail;
            fail("Can not match set " + name);
        }

        // Callback for when the mock is invoked. Note that not all mocks
        // support invoke. You need to specify that behavior in the factory.
        function invoke(var proxy, var pos, var named)
        {
            for (var expect in self.expectations) {
                if (expect.__can_match_invoke(pos, named)) {
                    expect.__match();
                    return expect.__run_will_behavior();
                }
            }
            using Assert.fail;
            fail("Can not match invoke");
        }

        /* Support Routines
            These routines are used internally to the Controller and should
            not be used by other code
        */

        // Get a count of remaining expecations which can accept a method of
        // the given name. We do this in find_method, before we invoke to save
        // effort.
        function method_expectations(string name)
        {
            int count = 0;
            for (var expect in self.expectations) {
                if (expect.type == "method" && expect.name == name && expect.__available())
                    count = count + 1;
            }
            return count;
        }

        // Attempt to match a method invoke to an expectation.
        function match_function(string name, var pos, var named)
        {
            for (var expect in self.expectations) {
                if (expect.__can_match_function_args(name, pos, named)) {
                    expect.__match();
                    return expect;
                }
            }
            // TODO: verbose list of failures
            using Assert.fail;
            fail("Unmatchable invocation of " + name);
        }
    }
}}
