/* Module Namespace
    A Module is a wrapper around the Parrot Packfile structure (specifically the
    PackfileView PMC) that provides reflection, introspection and new
    capabilities.

    This namespace provides some helper routines for working with Packfiles and
    Modules.
*/
namespace Rosella.Reflect.Module
{
    // Load the given .pbc file by name/path and create a Module for it. Modules
    // may be cached on the Packfile itself.
    function load(string name)
    {
        var pf_raw = load_packfile(name);
        var pf = new Rosella.Reflect.Module(pf_raw);
        pf.load();
        __set_cached_reflector(pf_raw, "module", pf);
        return pf;
    }
}

/* Module Class
    This class is a wrapper around a PackfileView PMC and provides additional
    functionality.
*/
class Rosella.Reflect.Module
{
    var pf;             // The PackfileView PMC
    var functions;      // A list of all functions provided by the Packfile
    var classes;        // A list of all classes defined at compile-time
    var namespaces;     // A list of all namespaces defined at compile-time

    // Constructor. Take an existing PackfileView
    function Module(var pf)
    {
        self.pf = pf;
    }

    // If not already done, execute all the "load" functions in the packfile
    function load()
    {
        Rosella.init_bytecode(self.pf, "load");
    }

    // If not already done, execute all the "init" functions in the packfile
    function init()
    {
        Rosella.init_bytecode(self.pf, "init");
    }

    // If provided, get the file path of the packfile
    function path()
    {
        if (self.pf == null)
            return "<UNINITIALIZED MODULE>";
        string p = string(self.pf);
        if (p == null || p == "")
            // TODO: If we don't have a path, we can try reading the annotations
            // in effect in the caller, and looking for a "file" annotation
            // to use.
            p = "<UNKNOWN>";
        return p;
    }

    // Get a string representation of the packfile
    function get_string[vtable]()
    {
        return sprintf("%s@%s", [self.path(), self.version()]);
    }

    // Get the version number information from the packfile
    function version()
    {
        if (self.pf == null)
            return "0.0.0";
        return self.pf.get_version();
    }

    // Get a list of classes defined at compile-time (from Sub metadata)
    function classes()
    {
        if (self.classes == null)
            self.__read_packfile_entries();
        return self.classes;
    }

    // Get a list of functions from the packfile
    function functions()
    {
        if (self.functions == null)
            self.__read_packfile_entries();
        return self.functions;
    }

    // Get a list of namespaces defined at compile-time (from Sub metadata)
    function namespaces()
    {
        if (self.namespaces == null)
            self.__read_packfile_entries();
        return self.namespaces;
    }

    // Internal helper function to read the entries from the packfile
    function __read_packfile_entries()
    {
        var all_subs = self.pf.all_subs();
        var all_namespaces = {};
        var all_classes = {};
        var functions = [];

        for (var sub in all_subs) {
            int sub_flags = sub.comp_flags();
            int pf_flags = sub.pf_flags();

            // Don't list subs marked :anon
            if ((pf_flags & PF_FLAG_ANON) != 0)
                continue;

            var ns_pmc = sub.get_namespace();
            var nsname = ns_pmc.get_name();
            nsname.shift(); // drop HLL namespace
            string ns = join(".", nsname);

            if ((sub_flags & SUB_FLAG_METHOD) != 0) {
                if (!(exists all_classes[ns])) {
                    var c = ns_pmc.get_class();
                    all_classes[ns] = Rosella.Reflect.get_class_reflector(c);
                }
            }
            else {
                if (!(exists all_namespaces[ns]))
                    all_namespaces[ns] = ns_pmc;
                all_namespaces[ns].add_sub(string(sub), sub);
                push(functions, sub);
            }
        }
        self.namespaces = all_namespaces;
        self.classes = all_classes;
        self.functions = functions;
    }
}
