/*
    The Rosella namespace is the base namespace of the Rosella library. All
    Rosella libraries are in their own namespaces nested under the ["Rosella"]
    namespace.

    This namespace provides a handful of basic functions which are used
    throughout rosella for some base functionality. These functions can be
    broken into two general groups: functions for creating new objects, and
    functions for working with types.
*/
namespace Rosella
{
    /* Allocation / Construction Functions
        These functions allocate a new object using some kind of proto-
        or meta-object. This meta-object can be a Class PMC, a PMC which can
        be used to look up a class (String, String array, NameSpace, Key),
        or something from the P6object system (P6metaclass, P6protoobject)
    */

    // Allocate a fresh new object from the meta-object. Do not manipulate it,
    // initialize it, or call any methods on it.
    function alloc(var proto)
    {
        var object;
        if (proto instanceof 'P6protoobject')
            object = proto.new();
        else {
            var obj_class = get_type_class(proto);
            ${ new object, obj_class };
        }
        return object;
    }

    // P6-ish initializer routine. Allocate a new object and call the BUILD
    // method on it, if it is defined.
    function build(var proto, var pos [slurpy], var named [slurpy, named])
    {
        var object = alloc(proto);
        var method = find_named_method(object, "BUILD");
        if (method != null)
            object.*method(pos:[flat], named:[flat,named]);
        return object;
    }

    // Construct a new object. Allocate a fresh object of the given type and
    // call the class constructor. The class constructor is a method with the
    // same name as the short name of the Class.
    function construct(var proto, var pos [slurpy], var named [slurpy,named])
    {
        var object = alloc(proto);
        var class_obj = get_type_class(proto);
        var method = find_named_method(object, class_obj.name());
        if (method != null)
            object.*method(pos:[flat], named:[flat,named]);
        return object;
    }

    /* Type Manipulation Functions
        These functions take a meta-object (one of the types listed above)
        and extracts useful information from them in a common way.
    */

    // Get the fully-qualified string name of the type
    function get_type_name(var type)
    {
        if (type instanceof "String")
            return type;

        if (type instanceof "P6protoobject")
            type = type.HOW().get_parrotclass(type.HOW()).get_namespace();
        else if (type instanceof "P6metaclass")
            type = type.get_parrotclass().get_namespace();
        else if (type instanceof "Class")
            type = type.get_namespace();
        else if (type instanceof "Key")
            ${ get_namespace type, type };

        if (type instanceof "NameSpace")
            return join("::", type.get_name());
        int is_array = 0;
        ${ does is_array, type, "array" };
        if (is_array)
            return join("::", type);
        return string(type);
    }

    // Get the Parrot Class PMC associated with the type.
    function get_type_class(var type)
    {
        if (type instanceof "P6metaclass")
            return type.get_parrotclass(type);
        if (type instanceof "P6protoobject")
            return type.HOW().get_parrotclass(type);
        if (type instanceof "Class")
            return type;

        if (type instanceof "String")
            type = split("::", type);
        var class_obj;
        ${ get_class class_obj, type };
        return class_obj;
    }

    // Determine if the given object is an instance of the given type.
    function isa(var type, var object)
    {
        int is_type = 0;
        var class_test = get_type_class(type);
        ${ isa is_type, object, class_test };
        return is_type;
    }

    /* Method-Utility Functions
        These functions help do things with functions and methods. These are
        NOT part of the standard API of the Rosella namespace, they only exist
        to help deal with shortcomings in various parts of the toolchain.
        These functions will disappear when they are no longer needed
    */

    // find a method PMC on the given object without throwing an exception on
    // failure.
    function find_named_method(var object, string meth_name)
    {
        int can_do = 0;
        ${ can can_do, object, meth_name };
        if (!can_do)
            return null;
        return find_method(object, meth_name);
    }
}

