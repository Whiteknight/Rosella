namespace Rosella { namespace Harness { namespace TestRun
{
    /* TestRun factory type.
        Builds TestRun objects, pre-populating them with a list of TestFile
        objects. The TestRun.Factory contains a TestFile.Factory, which is
        used to build the actual TestFile objects.
    */
    class Factory : Rosella.ObjectFactory
    {
        const int SORT_ORDER = 1;
        const int SORT_DEFAULT = 0;
        const int SORT_DISORDER = 2;
        var testfile_factory;
        var testfile_types;
        var tests;

        // Constructor
        function Factory()
        {
            self.ObjectFactory(class Rosella.Harness.TestRun);
            self.tests = [];
            self.testfile_factory = new Rosella.Harness.TestFile.Factory(class Rosella.Harness.TestFile.Automatic);
            self.testfile_types   = {};
            self.testfile_types["Automatic"] = class Rosella.Harness.TestFile.Automatic;
            self.testfile_types["NQP"]       = class Rosella.Harness.TestFile.NQP;
            self.testfile_types["PIR"]       = class Rosella.Harness.TestFile.PIR;
            self.testfile_types["Winxed"]    = class Rosella.Harness.TestFile.Winxed;
        }

        // Create the TestRun object
        function create_typed(var testrun_type, var p [slurpy], var n [slurpy,named])
        {
            var testrun = Rosella.construct(testrun_type, self.tests);
            self.tests = [];
            return testrun;
        }

        /* Routines for Adding and Managing Tests and Loaders
        */

        // Add a list of directories. Directories are searched, possibly
        // recursively, for a list of test files to run.
        function add_test_dirs(string testfile_type_s, var dirs [slurpy],
                int recurse [named,optional], int has_recurse [opt_flag],
                int sort [named,optional], int has_sort [opt_flag])
        {
            if (!has_recurse)
                recurse = 0;
            if (!has_sort)
                sort = SORT_DEFAULT;
            var testfile_type = null;
            if (testfile_type_s != null && testfile_type_s != "") {
                if (!(exists self.testfile_types[testfile_type_s]))
                    Rosella.Error.invalid(__FUNCTION__, "Cannot find test file type %s", testfile_type_s);
                testfile_type = self.testfile_types[testfile_type_s];
            }
            var tests = self.testfile_factory.create_tests_from_dirs(testfile_type, dirs, recurse);
            if (sort == SORT_ORDER)
                tests = self.sort_tests(tests);
            self.add_tests(tests);
        }

        // Add an individual test file
        function add_test_files(string testfile_type_s, var files [slurpy])
        {
            var testfile_type = self.testfile_types[testfile_type_s];
            var tests = self.testfile_factory.create_tests_from_files(testfile_type, files);
            self.add_tests(tests);
        }

        function add_tests(var tests)
        {
            for (var test in tests)
                push(self.tests, test);
        }

        // Add a new loader. If a loader exists with the same name, it is
        // overwritten
        function add_testfile_type(string name, var testfile_type)
        {
            self.testfile_types[name] = testfile_type;
        }

        /* Internal Helper Routines
        */

        function sort_tests(var tests)
        {
            return Rosella.Query.as_queryable(tests).sort(function(_a, _b) {
                string a = _a.filename();
                string b = _b.filename();
                if (a == b)
                    return 0;
                if (a < b)
                    return -1;
                return 1;
            }).data();
        }
    }
}}}
