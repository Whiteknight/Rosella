/* Query Library
    This library implements a series of higher-order functions for
    working with aggregates.

    To work with the Query library, you must wrap your aggregate in a
    Queryable. Use Query.as_queryable to do this easily. Once you have a
    Queryable, you can call and chain methods on it to produce results.
*/
namespace Rosella.Query
{
    // Get a Queryable. The optional second argument determines the type
    // of queryable wrapper to use. 0 (default) = a normal Queryable.
    // 1 = in-place queryable. In-place produces less churn, but is not
    // immutable.
    function as_queryable(var data)
    {
        return new Rosella.Query.Queryable(data);
    }

    function iterable(var d)
    {
        return Rosella.Query.default_iterable_factory().create(d);
    }

    function wrap_iterator(var i)
    {
        return new Rosella.Query.Iterable.Iterator(i);
    }

    // Helper function. Determine if the aggregate is an array
    function is_array(var data)
    {
        return does(data, "array");
    }

    // Helper function. Determine if the aggregate is a hash
    function is_hash(var data)
    {
        return does(data, "hash");
    }

    function is_iterator(var data)
    {
        return does(data, "iterator");
    }

    // Helper function. Excute one callback depending on whether the given
    // data is an array, a hash, or anything else.
    function array_or_hash(var data, var array_func, var hash_func, var scalar_func)
    {
        if (does(data, "array"))
            return array_func(data);
        if (does(data, "hash"))
            return hash_func(data);
        return scalar_func(data);
    }

    // Install some common Query methods to the given type. Useful for
    // built-in array and hash types.
    function install_to_type(var type)
    {
        var type_class = Rosella.get_type_class(type);
        type_class.add_method("queryable", function(var obj) {
            return Rosella.Query.as_queryable(obj);
        });
        type_class.add_method("iterable", function(var obj) {
            return Rosella.Query.iterable(obj);
        });
    }

    // Sort an array in-place. Optionally take a comparison function and a
    // hint flag that says whether the array should be considered already
    // mostly-sorted or mostly-reverse-sorted
    function sort_array(var d, var cmp [optional], int has_cmp [opt_flag],
            int is_sorted [optional,named], int has_is [opt_flag])
    {
        if (!has_cmp || cmp == null)
            cmp = Rosella.Query.Sort.get_default_comparer();
        if (has_is && is_sorted)
            Rosella.Query.Sort.timsort(d, cmp);
        else
            Rosella.Query.Sort.hybrid_quicksort(d, 0, elements(d), cmp);
    }

    /* Default Provider Factory
    */

    const string DEFAULT_PROVIDER_FACTORY = "Rosella.Query.default_provider_factory";

    // Get the global default provider factory
    function default_provider_factory()
    {
        var temp = Rosella.Globals.get_global(DEFAULT_PROVIDER_FACTORY);
        if (temp == null) {
            temp = new Rosella.Query.Provider.Factory(
                new Rosella.Query.Provider.Scalar(), {
                    "array" : new Rosella.Query.Provider.Array(),
                    "hash"  : new Rosella.Query.Provider.Hash()
                }, null);
            Rosella.Globals.register_global(DEFAULT_PROVIDER_FACTORY, temp);
        }
        return temp;
    }

    // Set a customer global provider factory
    function set_provider_factory(var factory)
    {
        Rosella.Globals.register_global(DEFAULT_PROVIDER_FACTORY, factory);
    }

    /* Default Iterable Factory
    */

    const string DEFAULT_ITERABLE_FACTORY = "Rosella.Query.default_iterable_factory";

    function default_iterable_factory()
    {
        var temp = Rosella.Globals.get_global(DEFAULT_ITERABLE_FACTORY);
        if (temp == null) {
            temp = new Rosella.Query.Iterable.Factory();
            Rosella.Globals.register_global(DEFAULT_ITERABLE_FACTORY, temp);
        }
        return temp;
    }
}
