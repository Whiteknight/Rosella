namespace Rosella { namespace Query
{
    /* Provider Namespace
        This namespace has some helper methods for maintaining singletons for
        various provider types. Providers tend not to have state, so they can
        be reused as singletons
    */
    namespace Provider
    {
        // Get the Array provider
        function get_array_provider()
        {
            var provider = new Rosella.Query.Provider.Array();
            while(1)
                yield provider;
        }

        // Get the Hash Provider
        function get_hash_provider()
        {
            var provider = new Rosella.Query.Provider.Hash();
            while(1)
                yield provider;
        }

        // Get the Scalar Provider
        function get_scalar_provider()
        {
            var provider = new Rosella.Query.Provider.Scalar();
            while(1)
                yield provider;
        }

        // lightly-optimized implementation of Quicksort.
        function qsort(var d, int s, int n, var cmp)
        {
            int last = n-1;
            while (last > s) {
                int pivot = s + int((n - s) / 2);
                int store = s;
                var tmp;

                var piv = d[pivot];
                d[pivot] = d[last];
                d[last] = piv;

                for(int ix = s; ix < last; ix++) {
                    if (cmp(d[ix], piv) < 0) {
                        tmp = d[store];
                        d[store] = d[ix];
                        d[ix] = tmp;
                        store++;
                    }
                }

                tmp = d[last];
                d[last] = d[store];
                d[store] = tmp;
                pivot = store;
                qsort(d, s, pivot, cmp);
                s = pivot + 1;
            }
        }

    }

    /* Provider Class
        This is an abstract base class for all Providers. It implements some
        common behaviors and specifies an interface that other Providers must
        use. Do not use this class directly, use a subclass.
    */
    class Provider
    {
        // Map the data
        function map(var data, var func)
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Filter the data
        function filter(var data, var func,
                int limit [optional], int has_limit [opt_flag])
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Fold the data
        function fold(var seed, var data, var func)
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Return a count of elements. If a predicate is provided, return a
        // count of elements which satisfy that predicate
        function count(var data, var func [optional], int has_func [opt_flag])
        {
            if (has_func && func != null)
                data = self.filter(data, func);
            int elems = 0;
            ${ elements elems, data };
            return elems;
        }

        // Return true if the aggregate contains any elements, or any elements
        // which match the predicate.
        function any(var data, var func [optional], int has_func [opt_flag])
        {
            int num;
            if (has_func) {
                data = self.take(data, 1, func);
                num = self.count(data);
            } else
                num = count(data);
            return (num > 0);
        }

        // Return the single element in the aggregate, or the single element
        // which matches the predicate. If there are more than or less than
        // exactly 1 elements, throw an exception.
        function single(var data, var func [optional], int has_func [opt_flag])
        {
            if (has_func)
                data = self.filter(data, func);
            if (self.count(data) != 1) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Aggregate has more than one entry");
            }
            return self.unwrap_first(data);
        }

        // Return the first element in the aggregate, or the first element
        // which matches the predicate. If there are none, throw an exception.
        function first(var data, var func [optional], int has_func [opt_flag])
        {
            if (has_func)
                data = self.take(data, 1, func);
            else
                data = self.take(data, 1);
            if (self.count(data) < 1) {
                using Rosella.Error.invalid;
                invalid(__FUNCTION__, "Aggregate does not have at least one entry");
            }
            return self.unwrap_first(data);
        }

        // Return the first element in the aggregate, or the first element
        // which matches the predicate. If there are none, return a default
        // value
        function first_or_default(var data,
                var func [optional], int has_func [opt_flag],
                var def [optional], int has_def [opt_flag])
        {
            if (has_func)
                data = self.take(data, 1, func);
            else
                data = self.take(data, 1);
            if (self.count(data) == 0) {
                if (has_def)
                    return def;
                return null;
            }
            return self.unwrap_first(data);
        }

        // Take from the data
        function take(var data, int count, var func [optional], int has_func [opt_flag])
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Skip some of the data
        function skip(var data, int count, var func [optional], int has_func [opt_flag])
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Combine two aggregates
        function combine(var a, var b,
                var filter [optional], int has_filter [opt_flag],
                var key_func [optional], int has_key_func [opt_flag],
                var dispute [optional], int has_dispute [opt_flag])
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        function unwrap_first(var data)
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Convert to an array
        function to_array(var data)
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Convert to a hash
        function to_hash(var data, var func)
        {
            using Rosella.Error.must_subclass;
            must_subclass("Rosella::Query::Provider");
        }

        // Convert the aggregate to an array and sort it, according to the
        // comparison function given.
        function sort(var data, var func)
        {
            var new_data = self.to_array(data);
            qsort(new_data, 0, elements(new_data), func);
            return new_data;
        }
    }
}}
