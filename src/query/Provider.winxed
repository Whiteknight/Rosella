namespace Rosella { namespace Query
{
    /* Provider Namespace
        This namespace has some helper methods for maintaining singletons for
        various provider types. Providers tend not to have state, so they can
        be reused as singletons
    */
    namespace Provider
    {
        // Get the Array provider
        function get_array_provider()
        {
            var provider = new Rosella.Query.Provider.Array();
            while(1)
                yield provider;
        }

        // Get the Hash Provider
        function get_hash_provider()
        {
            var provider = new Rosella.Query.Provider.Hash();
            while(1)
                yield provider;
        }

        // Get the Scalar Provider
        function get_scalar_provider()
        {
            var provider = new Rosella.Query.Provider.Scalar();
            while(1)
                yield provider;
        }

        // lightly-optimized implementation of Quicksort.
        function qsort(var d, int s, int n, var cmp)
        {
            int last = n-1;
            while (last > s) {
                int pivot = s + int((n - s) / 2);
                int store = s;
                var tmp;

                var piv = d[pivot];
                d[pivot] = d[last];
                d[last] = piv;

                for(int ix = s; ix < last; ix++) {
                    if (cmp(d[ix], piv) < 0) {
                        tmp = d[store];
                        d[store] = d[ix];
                        d[ix] = tmp;
                        store++;
                    }
                }

                tmp = d[last];
                d[last] = d[store];
                d[store] = tmp;
                pivot = store;
                qsort(d, s, pivot, cmp);
                s = pivot + 1;
            }
        }
    }

    /* Provider Class
        This is an abstract base class for all Providers. It implements some
        common behaviors and specifies an interface that other Providers must
        use. Do not use this class directly, use a subclass.
    */
    class Provider
    {
        function name()
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        function foreach(var data, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Map the data
        function map(var data, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Filter the data
        function filter(var data, var func,
                int limit [optional], int has_limit [opt_flag])
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Fold the data
        function fold(var seed, var data, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Return a count of elements. If a predicate is provided, return a
        // count of elements which satisfy that predicate
        function count(var data, var func)
        {
            if (func != null)
                data = self.filter(data, func);
            return elements(data);
        }

        // Return true if the aggregate contains any elements, or any elements
        // which match the predicate.
        function any(var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Return the single element in the aggregate, or the single element
        // which matches the predicate. If there are more than or less than
        // exactly 1 elements, throw an exception.
        function single(var data, var func)
        {
            if (func != null)
                data = self.filter(data, func);
            if (self.count(data, null) != 1)
                Rosella.Error.invalid(__FUNCTION__, "Aggregate has more than one entry");
            return self.unwrap_first(data);
        }

        // Return the first element in the aggregate, or the first element
        // which matches the predicate. If there are none, throw an exception.
        function first(var data, var func)
        {
            data = self.take(data, 1, func);
            if (self.count(data, null) < 1)
                Rosella.Error.invalid(__FUNCTION__, "Aggregate does not have at least one entry");
            return self.unwrap_first(data);
        }

        // Return the first element in the aggregate, or the first element
        // which matches the predicate. If there are none, return a default
        // value
        function first_or_default(var data, var func, var def)
        {
            data = self.take(data, 1, func);
            if (self.count(data, null) == 0)
                return def;
            return self.unwrap_first(data);
        }

        // Take from the data
        function take(var data, int count, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Skip some of the data
        function skip(var data, int count, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Combine two aggregates
        function combine(var a, var b,
                var filter [optional], int has_filter [opt_flag],
                var key_func [optional], int has_key_func [opt_flag],
                var dispute [optional], int has_dispute [opt_flag])
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        function unwrap_first(var data)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Convert to an array
        function to_array(var data)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Convert to a hash
        function to_hash(var data, var func)
        {
            Rosella.Error.must_subclass(__CLASS__);
        }

        // Convert the aggregate to an array and sort it, according to the
        // comparison function given.
        function sort(var data, var func)
        {
            var new_data = self.to_array(data);
            qsort(new_data, 0, elements(new_data), func);
            return new_data;
        }

        function keys(var data)
        {
            Rosella.Error.invalid(__FUNCTION__, "Provider %s does not support .keys()", self.name());
        }

        function flatten(var data)
        {
            var results = [];
            self.__flatten_internal(results, data);
            return results;
        }

        function __flatten_internal(var results, var data)
        {
            Rosella.Query.array_or_hash(data,
                function(a) {
                    for (var item in a)
                        self.__flatten_internal(results, item);
                },
                function(h) {
                    var a = Rosella.Query.as_queryable(h).to_array().data();
                    for (var item in a)
                        self.__flatten_internal(results, item);
                },
                function(s) { push(results, s); }
            );
        }
    }
}}
