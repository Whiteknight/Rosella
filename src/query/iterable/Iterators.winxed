class Rosella.Query.Iterable.Map : Rosella.Query.Iterable
{
    var mapper;

    function Map(var source, var f)
    {
        self.source = source;
        self.mapper = f;
    }

    function next()
    {
        var d = self.source.next();
        var f = self.mapper;
        return f(d);
    }
}

class Rosella.Query.Iterable.Filter : Rosella.Query.Iterable
{
    var cache;
    var has_cache;
    var func;

    function Filter(var source, var f)
    {
        self.has_cache = false;
        self.source = source;
        self.func = f;
    }

    function has_more()
    {
        var f = self.func;
        int m;
        int has_cache = int(self.has_cache);
        if (has_cache)
            return true;
        if (!self.source.has_more())
            return false;
        do {
            :(var d, m) = self.source.next_and_more();
            if (int(f(d)) == true) {
                self.cache = d;
                self.has_cache = true;
                return true;
            }
        } while(m == true);
        return false;
    }

    function next()
    {
        int has_cache = int(self.has_cache);
        if (has_cache) {
            var d = self.cache;
            self.cache = null;
            self.has_cache = false;
            return d;
        }

        if (!self.source.has_more())
            return false;

        var f = self.func;
        int m;
        do {
            :(var d, m) = self.source.next_and_more();
            if (int(f(d)) == true)
                return d;
        } while(m == true);
        self.empty();
    }
}

class Rosella.Query.Iterable.Append : Rosella.Query.Iterable
{
    var extra_sources;

    function Append(var first, var second)
    {
        self.source = first;
        self.extra_sources = [second];
    }

    function next()
    {
        while (!self.source.has_more()) {
            if (elements(self.extra_sources) == 0)
                self.empty();
            var s = self.extra_sources.shift();
            self.source = Rosella.Query.iterable(s);
        }
        return self.source.next();
    }

    function has_more()
    {
        if (self.source.has_more())
            return true;
        for (int i = 0; i < elements(self.extra_sources); i++) {
            if (elements(self.extra_sources[i]) > 0)
                return true;
        }
        return false;
    }

    function append(var d)
    {
        push(self.extra_sources, d);
        return self;
    }
}

class Rosella.Query.Iterable.TakeSkip : Rosella.Query.Iterable
{
    var take;
    var skip;
    var func;

    function TakeSkip(var source, var f, int take, int skip)
    {
        self.source = source;
        self.func = f;
        self.take = take;
        if (skip == 0)
            self.skip = null;
        else
            self.skip = skip;
    }

    function _skip()
    {
        int skip = self.skip;
        var f = self.func;

        if (skip > 0) {
            if (f != null) {
                int m = self.source.has_more();
                for (int i = 0; i < skip && m == true; ) {
                    :(var d, m) = self.source.next_and_more();
                    if (f(d))
                        i++;
                }
            } else {
                int m = self.source.has_more();
                for (int i = 0; i < skip && m == true; i++) {
                    :(var d, m) = self.source.next_and_more();
                }
            }
        }
        self.skip = null;
    }

    function next()
    {
        if (self.skip != null)
            self._skip();
        int take = int(self.take);
        if (take == 0 || !self.source.has_more())
            self.empty();
        :(var d, int m) = self.source.next_and_more()
        if (m == false)
            take = 0;
        else
            take--;
        self.take = take;
        return d;
    }

    function has_more()
    {
        if (self.skip != null)
            self._skip();
        int take = int(self.take);
        return take != 0 && self.source.has_more();
    }

    // TODO: We can probably optimize repeated take/skip calls to reuse the
    // same iterator
}

class Rosella.Query.Iterable.Flatten : Rosella.Query.Iterable
{
    var cache;
    var cached_item;
    var has_cached_item;

    function Flatten(var source)
    {
        self.source = source;
        self.has_cached_item = false;
    }

    function next()
    {
        if (!self.has_more())
            self.empty();

        do {
            if (self.has_cached_item == true) {
                var i = self.cached_item;
                self.cached_item = null;
                self.has_cached_item = false;
                return i;
            }

            if (self.cache.has_more()) {
                :(var d, int m) = self.cache.next_and_more();
                if (m == false)
                    self.cache = null;
                return d;
            } else
                self.cache = null;
        } while (self.has_more() == true);

        self.empty();
    }

    function has_more()
    {
        if (self.has_cached_item == true)
            return true;

        if (self.cache != null) {
            if (self.cache.has_more())
                return true;
            self.cache = null;
        }

        if (!self.source.has_more())
            return false;

        var d;
        int m;
        do {
            :(d, m) = self.source.next_and_more();
            var item;
            var has_item = false;
            var i = Rosella.Query.array_or_hash(d,
                function(var a) {
                    if (elements(a) > 0)
                        return new Rosella.Query.Iterable.Array(a);
                    return null;
                },
                function(var h) {
                    if (elements(h) > 0)
                        return new Rosella.Query.Iterable.Hash(h);
                    return null;
                },
                function(var s) {
                    self.cached_item = s;
                    self.has_cached_item = true;
                    return null;
                }
            );
            if (i == null) {
                if (int(self.has_cached_item) == true)
                    return true;
            } else {
                var cache = new Rosella.Query.Iterable.Flatten(i);
                if (cache.has_more()) {
                    self.cache = cache;
                    return true;
                }
            }
        } while (m == true);

        return false;
    }
}

class Rosella.Query.Iterable.Project : Rosella.Query.Iterable
{
    var func;
    var cache;

    function Project(var source, var f)
    {
        self.source = source;
        self.func = f;
        self.cache = null;
    }

    function next()
    {
        if (self.cache == null) {
            if (!self.source.has_more())
                self.empty();

            var f = self.func;
            :(var d, int m) = self.source.next_and_more();
            d = f(d);
            while (elements(d) == 0 && m == true) {
                :(d, m) = self.source.next_and_more();
                d = f(d);
            }
            if (m == false || elements(d) == 0)
                self.empty();
            self.cache = new Rosella.Query.Iterable.Array(d);
        }
        if (!self.cache.has_more())
            self.empty();

        :(var a, int o) = self.cache.next_and_more();
        if (o == false)
            self.cache = null;
        return a;
    }

    function has_more()
    {
        if (self.cache != null) {
            if (self.cache.has_more())
                return true;
            else
                self.cache = null;
        }
        if (!self.source.has_more())
            return false;

        var f = self.func;
        :(var d, int m) = self.source.next_and_more();
        d = f(d);
        while (elements(d) == 0 && m == true) {
            :(d, m) = self.source.next_and_more();
            d = f(d);
        }
        if (elements(d) == 0)
            return false;
        self.cache = new Rosella.Query.Iterable.Array(d);
        return self.cache.has_more();
    }
}

class Rosella.Query.Iterable.Tap : Rosella.Query.Iterable
{
    var func;

    function Tap(var source, var f)
    {
        self.source = source;
        self.func = f;
    }

    function next()
    {
        var d = self.source.next();
        var f = self.func;
        f(d);
        return d;
    }
}
