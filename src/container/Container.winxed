namespace Rosella.Container
{
    const string DEFAULT_CONTAINER_GLOBAL = "Rosella.Container.default_container";

    // A global-point of access for a default Container instance. Returns
    // the globally-registered default Container instance. By default this
    // is a plain vanilla Container, but that instance can be overridden.
    // Notice that you do not need to use this for your program, it is
    // only a convenience to help bootstrap dependency injection.
    function default_container()
    {
        var temp = Rosella.Globals.get_global(DEFAULT_CONTAINER_GLOBAL);
        if (temp == null) {
            temp = new Rosella.Container();
            Rosella.Globals.register_global(DEFAULT_CONTAINER_GLOBAL, temp);
        }
        return temp;
    }

    // Set the globally registered Container instance to something besides
    // the default.
    function set_default_container(var container)
    {
        Rosella.Globals.register_global(DEFAULT_CONTAINER_GLOBAL, container);
    }
}

/* Dependency Injection / Inversion of Control Container
    The Container class implements a dependency injection and type
    resolution system. Types are registered with the container, and later
    instances of those types can be resolved according to a set of
    resolution rules.
*/
class Rosella.Container
{
    var type_registry;
    var aliases;

    function Container()
    {
        var reg = {};
        reg.set_key_type(3);
        self.type_registry = reg;
        self.aliases = {};
    }

    function __sort_options(var type, var options)
    {
        var resolver = null;
        var build_options = [];
        var misc_options = [];
        for (var option in options) {
            if (option instanceof Rosella.Container.Resolver) {
                if (resolver != null)
                    self.multiple_resolvers_error(type);
                resolver = option;
                continue;
            }
            if (!(option instanceof Rosella.Container.Option)) {
                if (resolver != null)
                    self.multiple_resolvers_error(type);
                // it's an instance
                resolver = new Rosella.Container.Resolver.Instance(option);
                continue;
            }
            if (option instanceof Rosella.Container.Option.Build) {
                push(build_options, option);
                continue;
            }
            if (option instanceof Rosella.Container.Option) {
                push(misc_options, option);
                continue;
            }
            Rosella.Error.invalid(__FUNCTION__, "Invalid option: %s", typeof(option));
        }
        return resolver, build_options, misc_options;
    }

    function register(var type, var options [slurpy])
    {
        var type_class = Rosella.get_type_class(type);
        if (type_class == null)
            Rosella.Error.invalid(__FUNCTION__, "Attempt to register invalid or null type");
        :(var resolver, var build_options, var misc_options) = self.__sort_options(type_class, options);
        if (resolver == null)
            resolver = new Rosella.Container.Resolver.Type(type);
        resolver.set_options(build_options, misc_options);
        if (exists self.type_registry[type_class])
            resolver.previous(self.type_registry[type_class]);
        self.type_registry[type_class] = resolver;
        return self;
    }

    function unregister(var type)
    {
        var type_class = Rosella.get_type_class(type);
        if (exists self.type_registry[type_class]) {
            var old = self.type_registry[type_class].previous();
            if (old == null)
                delete self.type_registry[type_class];
            else
                self.type_registry[type_class] = old;
        }
        return self;
    }

    function multiple_resolvers_error(var type)
    {
        Rosella.Error.invalid(__FUNCTION__, "Multiple resolvers specified for type registration %", Rosella.get_type_name(type));
    }

    function alias(var type, string name)
    {
        var type_class = Rosella.get_type_class(type);
        if (type_class == null)
            Rosella.Error.invalid(__FUNCTION__, "Cannot setup alias '%s' for unknown class", name);
        self.aliases[name] = type_class;
    }

    function resolve[multi("pmc")](var type, var options [slurpy])
    {
        var type_class = Rosella.get_type_class(type);
        if (type_class == null)
            Rosella.Error.invalid(__FUNCTION__, "Cannot resolve unknown class");
        return self.__resolve_internal(type_class, options);
    }

    function resolve[multi(string)](string name, var options [slurpy])
    {
        if (exists self.aliases[name]) {
            var type = self.aliases[name];
            return self.__resolve_internal(type, options);
        } else
            Rosella.Error.invalid(__FUNCTION__, "Cannot resolve alias '%s'", name);
    }

    function __resolve_internal(var type, var options)
    {
        var type_class = Rosella.get_type_class(type);
        :(var resolver, var build_options, var misc_options) = self.__sort_options(type_class, options);
        if (resolver == null) {
            if (exists self.type_registry[type_class])
                resolver = self.type_registry[type_class];
            else
                Rosella.Error.invalid(__FUNCTION__, "No Resolver specified for type %s", type_class);
        }
        var instance = resolver.resolve(self, build_options, misc_options);
        return instance;
    }
}
