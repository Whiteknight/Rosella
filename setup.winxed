using extern "io_ops";

function main[main](argv) {
    setup_distutils();
    var rosella = {
        "name"             : 'Rosella',
        "abstract"         : 'Utilities Library for Parrot',
        "authority"        : 'http://github.com/Whiteknight',
        "copyright_holder" : 'Andrew Whitworth',
        "keywords"         : ["test", "tap", "xunit", "event", "container", "dependency injection"],
        "license_type"     : 'Artistic License 2.0',
        "license_uri"      : 'http://www.perlfoundation.org/artistic_license_2_0',
        "checkout_uri"     : 'git://github.com/Whiteknight/rosella.git',
        "browser_uri"      : 'git://github.com/Whiteknight/rosella',
        "project_uri"      : 'git://github.com/Whiteknight/rosella',
        "pir_nqp-rx"       : {},
        "pir_winxed"       : {},
        "pbc_pbc"          : {},
        "pbc_pir"          : {},
        "inst_lib"         : []
    };

    if (argv[1] == "test")
        do_test();


    // A distutils wrapper library which adds winxed functionality.
    // A bootstrapped version is included in the repo because we need it
    // to run setup.winxed (this script)
    var distutils_files = [
        "winxed/Distutils"
    ];
    setup_winxed_lib(rosella, "rosella/winxed_distutils.pbc", distutils_files);

    // The Rosella "core" library. Does very little on its own but is
    // required by other libraries in the sequence
    var core_files = [
        "core/Rosella",
        "core/Error",
        "core/ObjectFactory"
    ];
    //setup_nqp_lib(rosella, "rosella/core.pbc", core_files);
    setup_winxed_lib(rosella, "rosella/core.pbc", core_files);

    // The action library. Allows creating Action/Command objects for
    // delayed evaluation.
    var action_files = [
        "include/Core",
        "action/Action",
        "action/ActionArg"
    ];
    //setup_nqp_lib(rosella, "rosella/action.pbc", action_files);
    setup_winxed_lib(rosella, "rosella/action.pbc", action_files);

    // Dependency Injection / Inversion of Control container library
    var container_files = [
        "include/Core",
        "include/Action",
        "container/Container",
        "container/ItemBuilder"
    ];
    //setup_nqp_lib(rosella, "rosella/container.pbc", container_files);
    setup_winxed_lib(rosella, "rosella/container.pbc", container_files);

    var event_files = [
        "include/Core",
        "include/Action",
        "event/Event",
        "event/EventManager"
    ];
    //setup_nqp_lib(rosella, "rosella/event.pbc", event_files);
    setup_winxed_lib(rosella, "rosella/event.pbc", event_files);

    var proto_files = [
        "include/Core",
        "prototype/Item",
        "prototype/Manager"
    ];
    //setup_nqp_lib(rosella, "rosella/prototype.pbc", proto_files);
    setup_winxed_lib(rosella, "rosella/prototype.pbc", proto_files);

    var query_files = [
        "include/Core",
        "query/Query",
        "query/Provider",
        "query/provider/Array",
        "query/provider/Hash",
        "query/Path"
    ];
    setup_nqp_lib(rosella, "rosella/query.pbc", query_files);

    var test_files = [
        "include/Core",
        "test/Builder"
    ];
    //setup_nqp_lib(rosella, "rosella/test.pbc", test_files);
    setup_winxed_lib(rosella, "rosella/test.pbc", test_files);

    var xunit_files = [
        "include/Core",
        "include/Test",
        "xunit/Assertions",
        "xunit/Failure",
        "xunit/Listener",
        "xunit/Listener/TAP",
        "xunit/Loader",
        "xunit/Result",
        "xunit/Suite",
        "xunit/Testcase",
        "xunit/UnitTestFailure"
    ];
    setup_nqp_lib(rosella, "rosella/xunit.pbc", xunit_files);

//     my @mockobject_files := <
//         include/Core
//         mockobject/Antiphon
//         mockobject/Cuckoo
//         mockobject/Cuculus
//         mockobject/MockFS
//         mockobject/Ovum
//         mockobject/SigMatcher
//         mockobject/Verifier
//     >;
//     setup_lib(%rosella, "rosella/mockobject.pbc", @mockobject_files);

     var tap_harness_files = [
         "include/Core",
         "tap_harness/Harness",
         "tap_harness/Line",
         "tap_harness/Loader",
         "tap_harness/Output",
         "tap_harness/TestFile"
     ];
     setup_nqp_lib(rosella, "rosella/tap_harness.pbc", tap_harness_files);


    using WinxedDistutils.winxed_setup;
    argv.shift();
    winxed_setup(argv, rosella);
}

function setup_nqp_lib(var rosella, string name, var files) {
    var pbcs = [];
    for (string p_path in files) {
        string path = "src/" + p_path;
        string nqp_file = path + ".nqp";
        string pir_file = path + ".pir";
        string pbc_file = path + ".pbc";
        rosella["pir_nqp-rx"][pir_file] = nqp_file;
        rosella["pbc_pir"][pbc_file] = pir_file;
        pbcs.push(pbc_file);
    }
    rosella["pbc_pbc"][name] = pbcs;
    rosella["inst_lib"].push(name);
}

function setup_winxed_lib(var rosella, string name, var files) {
    var pbcs = [];
    for (string p_path in files) {
        string path = "src/" + p_path;
        string winxed_file = path + ".winxed";
        string pir_file = path + ".pir";
        string pbc_file = path + ".pbc";
        rosella["pir_winxed"][pir_file] = winxed_file;
        rosella["pbc_pir"][pbc_file] = pir_file;
        pbcs.push(pbc_file);
    }
    rosella["pbc_pbc"][name] = pbcs;
    rosella["inst_lib"].push(name);
}

// Load in the distutils library, which we are also responsible for
// building. If we don't have a version handy, load in the bootstrapping
// version. If we do have one built, use that instead
function setup_distutils() {
    int e = 0;
    string distutils = "src/winxed/Distutils.pir";
    ${ stat e, distutils, 0 };
    if (e)
        load_bytecode(distutils);
    else
        load_bytecode("src/winxed/DistutilsSt1.pir");
}

function do_test() {
    using get_nqp;
    string nqp = "parrot-nqp"; //get_nqp();
    string cmd = nqp + " t/harness";
    int result;
    ${ spawnw result, cmd };
    ${ exit result };
}

