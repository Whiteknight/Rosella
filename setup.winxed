using extern "io_ops";

function main[main](argv)
{
    setup_distutils();
    var rosella = {
        "name"              : 'Rosella',
        "abstract"          : 'Utilities Library for Parrot',
        "authority"         : 'http://github.com/Whiteknight',
        "copyright_holder"  : 'Andrew Whitworth',
        "keywords"          : ["test", "tap", "xunit", "event", "container", "dependency injection"],
        "license_type"      : 'Artistic License 2.0',
        "license_uri"       : 'http://www.perlfoundation.org/artistic_license_2_0',
        "checkout_uri"      : 'git://github.com/Whiteknight/rosella.git',
        "browser_uri"       : 'git://github.com/Whiteknight/rosella',
        "project_uri"       : 'git://github.com/Whiteknight/rosella',
        "pir_nqp-rx"        : {},
        "pir_winxed"        : {},
        "pbc_pbc"           : {},
        "pbc_pir"           : {},
        "pir_pir"           : {},
        "inst_lib"          : [],
        "installable_pbc"   : {},
        "include_winxed"    : {},
        "manifest_includes" : ["CREDITS", "README.md", "setup.winxed"]
    };

    if (argv[1] == "test")
        do_test();

    setup_release(rosella);
    setup_stable_libraries(rosella);
    setup_experimental_libraries(rosella);
    setup_utilities(rosella);

    get_all_tests(rosella, "t");
    argv.shift();
    setup(argv, rosella);
}

function setup_release(var rosella)
{
    rosella["pir_winxed"]["setup.pir"] = "setup.winxed";
    rosella["manifest_includes"].push("setup.pir");
}

function setup_stable_libraries(var rosella)
{
    // A distutils wrapper library which adds winxed functionality.
    // A bootstrapped version is included in the repo because we need it
    // to run setup.winxed (this script). This is the only rosella library
    // which doesn't rely on Core.
    setup_winxed_lib(rosella, "winxed", [],
        "winxed/Distutils",
        "winxed/Repl",
        "winxed/repl/Commands",
        "winxed/repl/CommandFuncs",
        "winxed/repl/Compiler",
        "winxed/repl/State",
        "winxed/repl/View"
    );

    // The Rosella "core" library. Does very little on its own but is
    // required by other libraries in the sequence
    setup_winxed_lib(rosella, "core", [],
        "core/Rosella",
        "core/Error",
        "core/IO",
        "core/ObjectFactory",
        "core/Parrot",
        "core/Version",
        "_build/_versions"
    );

    // The action library. Allows creating Action/Command objects for
    // delayed evaluation.
    setup_winxed_lib(rosella, "action", ["Core"],
        "action/Action",
        "action/action/Sub",
        "action/action/Method",
        "action/Argument",
        "action/argument/Instance"
    );

    // Dependency Injection / Inversion of Control container library
    setup_winxed_lib(rosella, "container", ["Core", "Action"],
        "container/Container",
        "container/ItemFactory",
        "container/itemfactory/ParrotClass",
        "container/itemfactory/P6protoobject",
        "container/itemfactory/Prototype",
        "container/itemfactory/FactoryMethod",
        "container/itemfactory/Instance",
        "container/action_argument/ContainerResolver"
    );

    // A proxying library for building and managing proxies
    setup_winxed_lib(rosella, "proxy", ["Core"],
        "proxy/Builder",
        "proxy/Controller",
        "proxy/Factory",
        "proxy/Proxy",
        "proxy/builder/Array",
        "proxy/builder/AttributeIntercept",
        "proxy/builder/Imitate",
        "proxy/builder/Immutable",
        "proxy/builder/InvokeIntercept",
        "proxy/builder/MethodIntercept",
        "proxy/builder/Passthrough",
        "proxy/builder/PMCKeyedHash",
        "proxy/builder/ProxyData",
        "proxy/builder/StringKeyedHash"
    );

    // A testing library for writing and running unit tests.
    setup_winxed_lib(rosella, "test", ["Core"],
        "test/Builder",
        "test/Asserter",
        "test/Failure",
        "test/Listener",
        "test/Listener/TAP",
        "test/Result",
        "test/Suite",
        "test/SuiteFactory",
        "test/Test",
        "test/TestCase",
        "test/TestContext",
        "test/TestFactory",
        "test/TestStatus"
    );

    // A mock object library for advanced unit testing
    setup_winxed_lib(rosella, "mockobject", ["Core", "Test", "Proxy"],
        "mockobject/Controller",
        "mockobject/controller/Ordered",
        "mockobject/Expectation",
        "mockobject/expectation/Get",
        "mockobject/expectation/Set",
        "mockobject/expectation/Method",
        "mockobject/expectation/Invoke",
        "mockobject/expectation/Will",
        "mockobject/expectation/With",
        "mockobject/Factory"
    );

    // A tap harness library for building easy, extensible test harnesses
    setup_winxed_lib(rosella, "harness", ["Core"],
        "harness/Harness",
        "harness/TestFile",
        "harness/testfile/Factory",
        "harness/testfile/Line",
        "harness/testfile/Custom",
        "harness/testfile/NQP",
        "harness/testfile/PIR",
        "harness/testfile/Winxed",
        "harness/TestRun",
        "harness/testrun/ResultSet",
        "harness/testrun/Factory",
        "harness/View"
    );

    // Event library. Subscribe to, receive, and publish event notifications.
    setup_winxed_lib(rosella, "event", ["Core", "Action"],
        "event/Event",
        "event/Manager"
    );

    // Memoization library. Allows multiple types of transparent Sub
    // memoization.
    setup_winxed_lib(rosella, "memoize", ["Core", "Proxy"],
        "memoize/Memoize",
        "memoize/Cache",
        "memoize/cache/Item",
        "memoize/cache/SimpleString",
        "memoize/Controller",
        "memoize/Factory"
    );

    // A library for working with aggregates
    setup_winxed_lib(rosella, "query", ["Core"],
        "query/Provider",
        "query/provider/Array",
        "query/provider/Hash",
        "query/provider/Scalar",
        "query/Query",
        "query/Queryable",
        "query/queryable/InPlace"
    );
}

function setup_experimental_libraries(var rosella)
{
    // A prototype library for managing a prototype-based object system
    setup_unstable_lib(rosella, "prototype", ["Core"],
        "prototype/Object",
        "prototype/Manager",
        "prototype/manager/Entry",
        "prototype/manager/ObjectCloner"
    );

    setup_unstable_lib(rosella, "path", ["Core"],
        "path/Path",
        "path/Searcher",
        "path/searcher/Hash",
        "path/searcher/Attribute"
    );

    // A library for creating and using cheap, transparent decorator
    setup_unstable_lib(rosella, "decorate", ["Core", "Proxy"],
        "decorate/Builder",
        "decorate/Decorator",
        "decorate/Factory"
    );

    setup_unstable_lib(rosella, "contract", ["Core"],
        "contract/Contract",
        "contract/Method",
        "contract/Interface"
    );

    setup_unstable_lib(rosella, "lazy", ["Core", "Proxy"],
        "lazy/Lazy",
        "lazy/Builder",
        "lazy/Controller",
        "lazy/Factory"
    );

    setup_unstable_lib(rosella, "string", ["Core"],
        "string/String",
        "string/Tokenizer",
        "string/tokenizer/CClass",
        "string/tokenizer/Token"
    );

    setup_unstable_lib(rosella, "filesystem", ["Core"],
        "filesystem/Entry",
        "filesystem/Directory",
        "filesystem/File",
        "filesystem/FileSystem",
        "filesystem/Visitor",
        "filesystem/visitor/Delete",
        "filesystem/visitor/Function",
        "filesystem/visitor/List",
        ["filesystem/Constants"]:[named("constants")]
    );

    setup_unstable_lib(rosella, "benchmark", [],
        "benchmark/Benchmark",
        "benchmark/Result"
    );
}

function setup_utilities(var rosella)
{
    var utilities = {"winxed_repl" : "winxed_repl"};
    string prefix = "src/unstable/utilities/";
    for (string util_source in utilities) {
        string winxed_file = prefix + util_source + ".winxed";
        string pir_file = prefix + util_source + ".pir";
        string pbc_file = prefix + util_source + ".pbc";
        string util = string(utilities[util_source]);

        rosella["pir_winxed"][pir_file] = winxed_file;
        rosella["pbc_pir"][pbc_file] = pir_file;
        rosella["installable_pbc"][util] = pbc_file;
    }
}

function setup_winxed_lib(var rosella, string name, var includes, var files [slurpy],
        var named [slurpy,named])
{
    setup_lib_internal(rosella, name, "src/", includes, files, named);
}

function setup_unstable_lib(var rosella, string name, var includes, var files [slurpy],
        var named [slurpy,named])
{
    setup_lib_internal(rosella, name, "src/unstable/", includes, files, named);
}

function setup_lib_internal(var rosella, string name, string prefix,
        var includes, var files_raw, var named)
{
    var pbc_files = [];
    var pir_files = [];
    setup_lib_constants(rosella, name, prefix, named);

    // Get a list of all files
    var files = [];
    for (string include in includes)
        push(files, "src/include/" + include);
    for (string file in files_raw)
        push(files, prefix + file);

    for (string path in files) {
        string winxed_file = path + ".winxed";
        string pir_file = path + ".pir";
        string pbc_file = path + ".pbc";
        rosella["pir_winxed"][pir_file] = winxed_file;
        rosella["pbc_pir"][pbc_file] = pir_file;
        pbc_files.push(pbc_file);
        pir_files.push(pir_file);
    }
    string pbc_lib_name = "rosella/" + name + ".pbc";
    string pir_lib_name = "rosella/" + name + ".pir";
    rosella["pbc_pbc"][pbc_lib_name] = pbc_files;
    rosella["pir_pir"][pir_lib_name] = pir_files;
    rosella["inst_lib"].push(pbc_lib_name);
    rosella["manifest_includes"].push(pir_lib_name);
}

function setup_lib_constants(var rosella, string name, string prefix, var args)
{
    var constants_files = args["constants"];
    if (constants_files == null || elements(constants_files) == 0)
        return;
    for (string constant_file in constants_files) {
        string pasm_file = sprintf("%s%s.pasm", [prefix, constant_file]);
        string winxed_file = sprintf("%s%s.winxed", [prefix, constant_file]);
        rosella["include_winxed"][pasm_file] = winxed_file;
    }
}



// Load in the distutils library, which we are also responsible for
// building. If we don't have a version handy, load in the bootstrapping
// version. If we do have one built, use that instead
function setup_distutils()
{
    int e = 0;
    string distutils = "src/winxed/Distutils.pir";
    ${ stat e, distutils, 0 };
    if (e)
        load_bytecode(distutils);
    else {
        say("Bootstrapping build with existing distutils library");
        load_bytecode("src/winxed/Distutils.bootstrap.pir");
    }

    using Rosella.Winxed.Distutils.winxed_setup;
    winxed_setup();
    using register_step_before;
    using build_version_file;
    using clean_version_file;
    register_step_before("build", build_version_file);
    register_step_before("clean", clean_version_file);
}

// TODO: "build" first, before we test.
function do_test()
{
    using get_nqp;
    string nqp = "parrot-nqp"; //get_nqp();
    string cmd = nqp + " t/harness";
    int result;
    ${ spawnw result, cmd };
    ${ exit result };
}

function get_all_tests(var rosella, string path)
{
    loadlib("os");
    var os = new 'OS';
    int STAT_ISREG = 0x8000;
    int STAT_ISDIR = 0x4000;
    var contents_raw = os.readdir(path);

    for (string file in contents_raw) {
        string entry = path + "/" + file;
        var stat = os.stat(entry);
        int mode = stat[2];
        int isdir = 0;
        ${ band isdir, mode, STAT_ISDIR };
        int isfile = 0;
        ${ band isfile, mode, STAT_ISREG };
        if (file[0] == ".")
            continue;
        if (isfile == STAT_ISREG && is_test(entry))
            rosella["manifest_includes"].push(entry);

        if (isdir == STAT_ISDIR)
            get_all_tests(rosella, entry);
    }
}

function is_test(string path)
{
    int len = length(path);
    string ext = substr(path, len - 2);
    if (ext == ".t")
        return 1;
    else
        return 0;
}

function build_version_file(var rosella)
{
    using newer;
    string file = "src/_build/_versions.winxed";
    int e = 0;
    ${ stat e, file, 0 };
    if (!e || newer("VERSION", file))
        build_and_compile_version_file(rosella);
}

function clean_version_file(var rosella)
{
    string file = "src/_build/_versions.winxed";
    using unlink;
    int e = 0;
    ${ stat e, file, 0 };
    if (e) {
        say("unlink " + file);
        unlink(file);
    }
}

function build_and_compile_version_file(var rosella)
{
    print("Reading version information...");
    var verfile = new 'FileHandle';
    verfile.open('VERSION', 'r');
    string text = verfile.readall();
    verfile.close();
    var lines = split("\n", text);

    var code = new 'StringBuilder';
    string preamble = <<:
namespace Rosella { namespace __PRIVATE_Versions
{
    // This file is automatically generated by setup.winxed.
    // DO NOT MODIFY THIS FILE YOURSELF
    // Seriously, it's a bad idea.
    function __SET_VERSIONS[anon,init,load]()
    {
        using Rosella.internal_set_version;
:>>
;
    push(code, preamble);

    for (string line in lines) {
        var parts = split(': ', line);
        if (elements(parts) != 2)
            continue;
        string libname = parts[0];
        parts = split(' ', parts[1]);
        push(code, sprintf("        internal_set_version('%s', '%s', '%s');\n", [libname, parts[0], parts[1]]));
    }
    string postamble = <<:
    }
}}
:>>
;
    push(code, postamble);

    var file = new 'FileHandle';
    file.open("src/_build/_versions.winxed", "w");
    file.print(string(code));
    file.close();
    say("done.");
}
